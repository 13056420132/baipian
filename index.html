<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>WebAR Tarot - Celestial Oracle</title>
    <!-- Google Fonts: Cinzel & Lato -->
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700;900&family=Lato:wght@300;400;700&family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #05081a;
            --accent-color: #c5a059; /* å…¸é›…é‡‘ */
            --highlight-color: #ffd700; /* æ˜Ÿæ˜Ÿé‡‘ */
            --text-primary: #ffffff;
            --text-secondary: #b0b8d1;
            --panel-bg: rgba(10, 15, 40, 0.85);
            --card-bg: rgba(15, 25, 60, 0.95);
            --border-color: rgba(197, 160, 89, 0.4);
            --glow-color: rgba(197, 160, 89, 0.2);
        }

        html, body { width: 100%; height: 100%; margin: 0; padding: 0; overflow: hidden; }
        body { background-color: var(--bg-color); font-family: 'Lato', sans-serif; user-select: none; color: var(--text-primary); }
        
        #canvas-container { 
            width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; 
            background: radial-gradient(circle at 50% 50%, #0a1540 0%, #05081a 100%); 
        }
        
        /* é­”æ³•æ˜Ÿç©ºèƒŒæ™¯å¾®ç²’ (CSS æ¨¡æ‹Ÿ) */
        #canvas-container::after {
            content: ''; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background-image: 
                radial-gradient(white, rgba(255,255,255,.2) 2px, transparent 3px),
                radial-gradient(white, rgba(255,255,255,.15) 1px, transparent 2px),
                radial-gradient(rgba(255,255,255,.4), rgba(255,255,255,.1) 2px, transparent 3px);
            background-size: 550px 550px, 350px 350px, 250px 250px;
            background-position: 0 0, 40px 60px, 130px 270px;
            opacity: 0.3;
            pointer-events: none;
        }

        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 2; pointer-events: none; }

        /* Loader */
        #loader { 
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            font-family: 'Cinzel', serif; color: var(--accent-color);
            background: var(--panel-bg); padding: 40px 60px; 
            border: 1px solid var(--accent-color); 
            border-radius: 4px;
            backdrop-filter: blur(15px);
            box-shadow: 0 0 50px rgba(197, 160, 89, 0.15), inset 0 0 20px rgba(197, 160, 89, 0.1);
            pointer-events: auto; text-transform: uppercase; letter-spacing: 4px;
            text-align: center;
        }
        
        /* Controls */
        #controls { position: absolute; top: 30px; right: 30px; pointer-events: auto; display: flex; gap: 15px; }
        .btn { 
            background: rgba(10, 20, 50, 0.6);
            backdrop-filter: blur(10px);
            border: 1px solid var(--border-color); 
            color: var(--accent-color); 
            padding: 12px 28px; 
            cursor: pointer; 
            font-family: 'Cinzel', serif;
            font-weight: 700;
            font-size: 14px; 
            border-radius: 2px;
            transition: all 0.4s cubic-bezier(0.23, 1, 0.32, 1);
            text-transform: uppercase;
            letter-spacing: 1.5px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        }
        .btn:hover { 
            border-color: var(--highlight-color);
            color: var(--highlight-color);
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(197, 160, 89, 0.25);
            background: rgba(197, 160, 89, 0.1);
        }
        .btn.active { 
            background: var(--accent-color); 
            color: #05081a; 
            border-color: var(--accent-color); 
            box-shadow: 0 0 25px rgba(197, 160, 89, 0.4); 
        }

        /* History Panel */
        #history-panel { 
            position: absolute; top: 30px; left: 30px; 
            width: 320px; max-height: 80vh; 
            overflow-y: hidden; 
            pointer-events: auto; 
            display: flex; flex-direction: column;
            gap: 15px;
        }

        /* Reading Panel */
        .reading-panel{
            position: absolute;
            top: 30px;
            right: 30px;
            width: 380px;
            max-height: 85vh;
            pointer-events: auto;
            background: linear-gradient(145deg, rgba(15, 25, 60, 0.98), rgba(5, 10, 30, 0.99));
            border: 1px solid var(--accent-color);
            border-radius: 4px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.7), inset 0 0 30px rgba(197, 160, 89, 0.05);
            backdrop-filter: blur(20px);
            overflow: hidden;
            transform: translateY(0);
            opacity: 1;
            transition: all 0.5s cubic-bezier(0.19, 1, 0.22, 1);
        }
        .reading-panel.hidden{
            opacity: 0;
            transform: translateY(20px);
            pointer-events: none;
        }
        .reading-header{
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 20px 24px;
            border-bottom: 1px solid rgba(197, 160, 89, 0.2);
            background: rgba(197, 160, 89, 0.05);
        }
        .reading-title #reading-name{
            font-family: 'Cinzel', serif;
            font-weight: 900;
            color: var(--highlight-color);
            letter-spacing: 2px;
            font-size: 20px;
            text-shadow: 0 0 15px rgba(255,215,0,0.3);
        }
        .reading-orientation{
            margin-top: 4px;
            font-size: 13px;
            color: var(--accent-color);
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .reading-actions{
            display: flex;
            gap: 15px;
        }
        .btn.btn-mini{
            padding: 8px 16px;
            font-size: 12px;
        }
        .reading-body{
            padding: 24px;
            color: var(--text-secondary);
            font-size: 15px;
            line-height: 1.8;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            max-height: calc(85vh - 80px);
        }
        .reading-body h4{
            font-family: 'Cinzel', serif;
            margin: 24px 0 12px 0;
            font-size: 14px;
            color: var(--accent-color);
            letter-spacing: 2px;
            text-align: center;
            border-bottom: 1px solid rgba(197, 160, 89, 0.15);
            padding-bottom: 10px;
            text-transform: uppercase;
        }
        .reading-body p{
            margin: 0 0 15px 0;
            text-align: justify;
        }
        .reading-chip{
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 6px 14px;
            border-radius: 2px;
            border: 1px solid rgba(197, 160, 89, 0.3);
            background: rgba(197, 160, 89, 0.08);
            color: var(--accent-color);
            font-size: 11px;
            margin: 0 10px 15px 0;
            font-family: 'JetBrains Mono', monospace;
            text-transform: uppercase;
        }

        /* AI Reading Section Styles */
        .ai-header {
            margin-top: 30px;
            padding: 12px 15px;
            border: 1px solid var(--accent-color);
            border-bottom: none;
            color: var(--highlight-color);
            font-family: 'Cinzel', serif;
            font-size: 13px;
            letter-spacing: 2px;
            display: flex;
            align-items: center;
            gap: 10px;
            background: rgba(197, 160, 89, 0.1);
            border-radius: 4px 4px 0 0;
        }
        .ai-content {
            font-size: 15px;
            line-height: 1.8;
            color: #d0d8ff;
            background: rgba(5, 10, 30, 0.8);
            padding: 20px;
            border-radius: 0 0 4px 4px;
            border: 1px solid var(--accent-color);
            box-shadow: inset 0 0 20px rgba(0,0,0,0.5);
            font-family: 'Lato', sans-serif;
        }

        /* AI Context (Prompt Variables) */
        .ai-context{
            margin-top: 18px;
            padding: 14px;
            border: 1px solid rgba(197, 160, 89, 0.25);
            background: rgba(197, 160, 89, 0.06);
        }
        .ai-context-title{
            font-family: 'Cinzel', serif;
            font-weight: 700;
            letter-spacing: 1.5px;
            color: var(--accent-color);
            font-size: 12px;
            text-transform: uppercase;
            margin-bottom: 10px;
            display:flex;
            align-items:center;
            justify-content: space-between;
            gap: 10px;
        }
        .ai-fields{
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }
        .ai-field{
            display:flex;
            flex-direction: column;
            gap: 6px;
        }
        .ai-label{
            font-size: 11px;
            color: rgba(255, 215, 0, 0.8);
            letter-spacing: 1px;
            text-transform: uppercase;
            font-family: 'JetBrains Mono', monospace;
        }
        .ai-input, .ai-select{
            background: rgba(5, 10, 30, 0.85);
            border: 1px solid rgba(197, 160, 89, 0.35);
            color: #e6edff;
            border-radius: 2px;
            padding: 10px 10px;
            outline: none;
            font-size: 13px;
            font-family: 'Lato', sans-serif;
        }
        .ai-input{
            min-height: 64px;
            resize: vertical;
            grid-column: 1 / -1;
        }
        .btn.btn-mini.btn-ghost{
            background: rgba(5, 10, 30, 0.25);
            border-color: rgba(197, 160, 89, 0.35);
            color: var(--highlight-color);
        }
        .btn.btn-mini.btn-ghost:hover{
            background: rgba(197, 160, 89, 0.16);
        }
        
        .history-item { 
            background: linear-gradient(135deg, rgba(15, 25, 60, 0.9), rgba(5, 10, 30, 0.95));
            border: 1px solid var(--border-color);
            border-radius: 2px;
            padding: 18px; 
            animation: slideIn 0.5s cubic-bezier(0.23, 1, 0.32, 1);
            position: relative;
            backdrop-filter: blur(10px);
            box-shadow: 0 10px 25px rgba(0,0,0,0.4);
            transition: all 0.3s ease;
            cursor: pointer;
        }
        .history-item:hover {
            transform: scale(1.02);
            border-color: var(--highlight-color);
            box-shadow: 0 0 15px rgba(197, 160, 89, 0.3);
            background: rgba(197, 160, 89, 0.05);
        }

        .history-name { 
            color: var(--highlight-color); 
            font-family: 'Cinzel', serif;
            font-weight: 700; font-size: 16px; 
            letter-spacing: 1px; margin-bottom: 6px; 
            display: flex; justify-content: space-between;
            text-shadow: 0 0 15px rgba(255, 215, 0, 0.3);
        }
        .history-meaning { color: var(--text-secondary); font-size: 13px; line-height: 1.6; font-weight: 400; }
        .reversed-tag { 
            color: #ff6b6b; 
            background: rgba(255, 107, 107, 0.1);
            font-size: 10px; 
            border: 1px solid #ff6b6b; 
            padding: 2px 8px; 
            border-radius: 2px; 
            margin-left: 10px; 
            vertical-align: middle;
            font-family: 'Cinzel', serif;
        }

        /* Status & Charge */
        #status-container {
            position: absolute; bottom: 50px; width: 100%; 
            display: flex; flex-direction: column; align-items: center; 
            pointer-events: none;
        }
        #status-text { 
            color: #fff; 
            font-family: 'Cinzel', serif; 
            font-weight: 700;
            font-size: 16px; 
            letter-spacing: 2px;
            background: rgba(10, 15, 40, 0.9);
            padding: 14px 35px;
            border-radius: 4px;
            border: 1px solid var(--accent-color);
            backdrop-filter: blur(10px);
            box-shadow: 0 10px 30px rgba(0,0,0,0.5), 0 0 15px rgba(197, 160, 89, 0.2);
            text-transform: uppercase;
        }
        
        #charge-bar-container {
            width: 240px; height: 4px; 
            background: rgba(255,255,255,0.1); 
            border-radius: 2px;
            margin-top: 15px; overflow: hidden;
            position: relative;
        }
        #charge-bar {
            width: 0%; height: 100%; 
            background: var(--highlight-color); 
            box-shadow: 0 0 15px var(--highlight-color);
            transition: width 0.05s linear;
            border-radius: 2px;
        }

        /* Mobile Optimization */
        @media (max-width: 768px) {
            :root{
                --safe-top: env(safe-area-inset-top, 0px);
                --safe-bottom: env(safe-area-inset-bottom, 0px);
            }
            #history-panel { 
                top: auto; bottom: 0; left: 0; 
                width: 100%; height: 140px; 
                max-height: 25vh; 
                flex-direction: row; 
                overflow-x: auto; 
                overflow-y: hidden;
                background: linear-gradient(to top, rgba(11, 5, 24, 0.95), transparent); 
                padding: 12px; 
                box-sizing: border-box; 
                gap: 15px;
                scrollbar-width: none; /* Hide scrollbar Firefox */
                overscroll-behavior: contain;
                -webkit-overflow-scrolling: touch;
                padding-bottom: calc(12px + var(--safe-bottom));
            }
            #history-panel::-webkit-scrollbar { display: none; } /* Hide scrollbar Chrome/Safari */

            .history-item { 
                flex: 0 0 140px; /* Horizontal scroll items */
                height: 110px;
                margin-bottom: 0; 
                border-radius: 12px; 
                padding: 10px; 
                font-size: 11px;
                display: flex;
                flex-direction: column;
                justify-content: center;
            }
            .history-name { font-size: 13px; margin-bottom: 4px; }
            .history-meaning { 
                display: -webkit-box;
                line-clamp: 3;
                -webkit-line-clamp: 3;
                -webkit-box-orient: vertical;
                overflow: hidden;
                font-size: 11px;
            }

            #controls { 
                top: calc(10px + var(--safe-top)); 
                left: 10px;
                right: 10px; 
                gap: 8px; 
                justify-content: space-between;
            }
            .btn { 
                padding: 10px 12px; 
                font-size: 12px; 
                flex: 1;
                text-align: center;
            }

            #status-container { bottom: calc(160px + var(--safe-bottom)); } 
            #status-text { font-size: 13px; padding: 10px 20px; }

            .reading-panel {
                left: 0; right: 0; top: auto; bottom: 0;
                width: 100%; height: min(78dvh, 78vh);
                max-height: min(78dvh, 78vh);
                border-radius: 24px 24px 0 0;
                transform: translateY(100%);
                z-index: 1000;
                display: flex;
                flex-direction: column;
            }
            .reading-panel.hidden {
                transform: translateY(100%);
                opacity: 1; /* Keep visible for transition */
            }
            .reading-panel:not(.hidden) {
                transform: translateY(0);
            }
            .reading-header{
                position: sticky;
                top: 0;
                z-index: 2;
                padding: 14px 16px;
                backdrop-filter: blur(18px);
                flex: 0 0 auto;
            }
            .reading-body {
                max-height: none;
                flex: 1 1 auto;
                min-height: 0; /* critical: allow inner scrolling inside flex container */
                overflow-y: auto;
                -webkit-overflow-scrolling: touch;
                overscroll-behavior: contain;
                padding: 14px 16px calc(18px + var(--safe-bottom)) 16px;
            }
            .ai-content { font-size: 13px; padding: 12px; }

            /* AI context form: single column + compact */
            .ai-context{ padding: 12px; }
            .ai-context-title{ 
                flex-direction: column;
                align-items: flex-start;
                gap: 8px;
            }
            .ai-fields{ grid-template-columns: 1fr; }
            .ai-input{ min-height: 56px; }
        }
        
        /* Hand Pointer */
        #hand-pointer {
            position: absolute;
            width: 24px;
            height: 24px;
            background: var(--highlight-color);
            border-radius: 50%;
            pointer-events: none;
            z-index: 10000;
            display: none;
            box-shadow: 0 0 15px var(--highlight-color), 0 0 30px var(--accent-color);
            transition: transform 0.1s ease-out;
            border: 2px solid white;
        }
        #hand-pointer.active {
            transform: scale(1.5);
            background: #fff;
        }
        #hand-pointer.pinch {
            background: #00ff00;
            box-shadow: 0 0 20px #00ff00;
        }
        #hand-pointer.fist {
            background: #ff0000;
            box-shadow: 0 0 20px #ff0000;
        }
        @keyframes slideIn { from { opacity: 0; transform: translateY(20px) scale(0.9); } to { opacity: 1; transform: translateY(0) scale(1); } }
    </style>
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- MediaPipe Hands -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="canvas-container"></div>
    <video class="input_video"></video>
    <div id="hand-pointer"></div>

    <div id="ui-layer">
        <div id="loader">
            <div>åˆå§‹åŒ–ç¥ç§˜é¢†åŸŸ...</div>
            <div id="loading-details" style="font-size: 14px; margin-top: 10px; color: #888;">åŠ è½½èµ„æºä¸­</div>
        </div>

        <div id="controls">
            <button class="btn" id="btn-mouse" onclick="inputManager.setMode('mouse')">ğŸ–±ï¸ é¼ æ ‡æ¨¡å¼</button>
            <button class="btn active" id="btn-hand" onclick="inputManager.setMode('hand')">âœ‹ æ‰‹åŠ¿æ¨¡å¼</button>
        </div>

        <div id="history-panel">
            <!-- History items will be injected here -->
        </div>

        <!-- Reading Panel -->
        <div id="reading-panel" class="reading-panel hidden">
            <div class="reading-header">
                <div class="reading-title">
                    <div id="reading-name">å¡”ç½—è§£è¯»</div>
                    <div id="reading-orientation" class="reading-orientation">â€”</div>
                </div>
                <div class="reading-actions">
                    <button class="btn btn-mini" id="btn-copy-reading">å¤åˆ¶</button>
                    <button class="btn btn-mini" id="btn-close-reading">å…³é—­</button>
                </div>
            </div>
            <div id="reading-body" class="reading-body"></div>
        </div>

        <div id="status-container">
            <div id="status-text">åˆå§‹åŒ–ä¸­...</div>
            <div id="charge-bar-container">
                <div id="charge-bar"></div>
            </div>
        </div>
    </div>

<script>
/**
 * å¡”ç½—ç‰Œæ•°æ® (Rider-Waite-Smith ç®€æ˜“åº“)
 * å›¾ç‰‡æ¥æºï¼šGithub é•œåƒ
 */
const TAROT_DATA = [
    { id: 'fool', name: 'The Fool (æ„šè€…)', url: 'https://upload.wikimedia.org/wikipedia/commons/9/90/RWS_Tarot_00_Fool.jpg', upright: 'æ–°çš„å¼€å§‹ã€å†’é™©ã€çº¯çœŸ', reversed: 'é²è½ã€å†’é™©å¸¦æ¥çš„é£é™©' },
    { id: 'magician', name: 'The Magician (é­”æœ¯å¸ˆ)', url: 'https://upload.wikimedia.org/wikipedia/commons/d/de/RWS_Tarot_01_Magician.jpg', upright: 'æ„å¿—åŠ›ã€åˆ›é€ ã€æ˜¾åŒ–', reversed: 'æ¬ºéª—ã€ç¼ºä¹åˆ›é€ åŠ›' },
    { id: 'priestess', name: 'High Priestess (å¥³ç¥­å¸)', url: 'https://upload.wikimedia.org/wikipedia/commons/8/88/RWS_Tarot_02_High_Priestess.jpg', upright: 'ç›´è§‰ã€æ½œæ„è¯†ã€ç¥ç§˜', reversed: 'å‹æŠ‘ç›´è§‰ã€è‚¤æµ…' },
    { id: 'empress', name: 'The Empress (çš‡å)', url: 'https://upload.wikimedia.org/wikipedia/commons/d/d2/RWS_Tarot_03_Empress.jpg', upright: 'ä¸°é¥¶ã€æ¯æ€§ã€è‡ªç„¶', reversed: 'ä¾èµ–ã€åˆ›é€ åŠ›å—é˜»' },
    { id: 'emperor', name: 'The Emperor (çš‡å¸)', url: 'https://upload.wikimedia.org/wikipedia/commons/c/c3/RWS_Tarot_04_Emperor.jpg', upright: 'æƒå¨ã€ç»“æ„ã€çˆ¶æ€§', reversed: 'æš´æ”¿ã€ç¼ºä¹çºªå¾‹' },
    { id: 'hierophant', name: 'The Hierophant (æ•™çš‡)', url: 'https://upload.wikimedia.org/wikipedia/commons/8/8d/RWS_Tarot_05_Hierophant.jpg', upright: 'ä¼ ç»Ÿã€ç²¾ç¥æŒ‡å¼•', reversed: 'åå›ã€æ–°çš„ä¿¡ä»°' },
    { id: 'lovers', name: 'The Lovers (æ‹äºº)', url: 'https://upload.wikimedia.org/wikipedia/commons/3/3a/RWS_Tarot_06_Lovers.jpg', upright: 'çˆ±ã€å’Œè°ã€é€‰æ‹©', reversed: 'ä¸å¹³è¡¡ã€åˆ†ç¦»' },
    { id: 'chariot', name: 'The Chariot (æˆ˜è½¦)', url: 'https://upload.wikimedia.org/wikipedia/commons/9/9b/RWS_Tarot_07_Chariot.jpg', upright: 'æ§åˆ¶ã€æ„å¿—åŠ›ã€èƒœåˆ©', reversed: 'å¤±æ§ã€ä¾µç•¥' },
    { id: 'strength', name: 'Strength (åŠ›é‡)', url: 'https://upload.wikimedia.org/wikipedia/commons/f/f5/RWS_Tarot_08_Strength.jpg', upright: 'å‹‡æ°”ã€è€å¿ƒã€åŒæƒ…', reversed: 'è½¯å¼±ã€è‡ªæˆ‘æ€€ç–‘' },
    { id: 'hermit', name: 'The Hermit (éšå£«)', url: 'https://upload.wikimedia.org/wikipedia/commons/4/4d/RWS_Tarot_09_Hermit.jpg', upright: 'å†…çœã€å¯»æ‰¾çœŸç†', reversed: 'å­¤ç‹¬ã€å­¤ç«‹' },
    { id: 'wheel', name: 'Wheel of Fortune (å‘½è¿ä¹‹è½®)', url: 'https://upload.wikimedia.org/wikipedia/commons/3/3c/RWS_Tarot_10_Wheel_of_Fortune.jpg', upright: 'å¥½è¿ã€ä¸šåŠ›ã€è½¬æŠ˜ç‚¹', reversed: 'å„è¿ã€æŠµæŠ—å˜åŒ–' },
    { id: 'justice', name: 'Justice (æ­£ä¹‰)', url: 'https://upload.wikimedia.org/wikipedia/commons/e/e0/RWS_Tarot_11_Justice.jpg', upright: 'å…¬æ­£ã€çœŸç†ã€å› æœ', reversed: 'ä¸å…¬ã€é€ƒé¿è´£ä»»' },
    { id: 'hanged_man', name: 'The Hanged Man (å€’åŠäºº)', url: 'https://upload.wikimedia.org/wikipedia/commons/2/2b/RWS_Tarot_12_Hanged_Man.jpg', upright: 'ç‰ºç‰²ã€æ–°è§†è§’ã€ç­‰å¾…', reversed: 'æ— è°“çš„ç‰ºç‰²ã€åœæ»' },
    { id: 'death', name: 'Death (æ­»ç¥)', url: 'https://upload.wikimedia.org/wikipedia/commons/d/d7/RWS_Tarot_13_Death.jpg', upright: 'ç»“æŸã€è½¬å˜ã€é‡ç”Ÿ', reversed: 'æŠ—æ‹’æ”¹å˜ã€åœæ»' },
    { id: 'temperance', name: 'Temperance (èŠ‚åˆ¶)', url: 'https://upload.wikimedia.org/wikipedia/commons/f/f8/RWS_Tarot_14_Temperance.jpg', upright: 'å¹³è¡¡ã€é€‚åº¦ã€è€å¿ƒ', reversed: 'ä¸å¹³è¡¡ã€è¿‡åº¦' },
    { id: 'devil', name: 'The Devil (æ¶é­”)', url: 'https://upload.wikimedia.org/wikipedia/commons/5/55/RWS_Tarot_15_Devil.jpg', upright: 'æŸç¼šã€ç‰©è´¨ä¸»ä¹‰', reversed: 'æ‰“ç ´æŸç¼šã€é‡è·è‡ªç”±' },
    { id: 'tower', name: 'The Tower (å¡”)', url: 'https://upload.wikimedia.org/wikipedia/commons/5/53/RWS_Tarot_16_Tower.jpg', upright: 'çªå˜ã€æ··ä¹±ã€å¯ç¤º', reversed: 'é¿å…ç¾éš¾ã€å»¶è¿Ÿæ”¹å˜' },
    { id: 'star', name: 'The Star (æ˜Ÿæ˜Ÿ)', url: 'https://upload.wikimedia.org/wikipedia/commons/d/db/RWS_Tarot_17_Star.jpg', upright: 'å¸Œæœ›ã€çµæ„Ÿã€å®é™', reversed: 'ç»æœ›ã€ç¼ºä¹ä¿¡å¿ƒ' },
    { id: 'moon', name: 'The Moon (æœˆäº®)', url: 'https://upload.wikimedia.org/wikipedia/commons/7/7f/RWS_Tarot_18_Moon.jpg', upright: 'å¹»è§‰ã€ææƒ§ã€æ½œæ„è¯†', reversed: 'é‡Šæ”¾ææƒ§ã€æ¸…æ™°' },
    { id: 'sun', name: 'The Sun (å¤ªé˜³)', url: 'https://upload.wikimedia.org/wikipedia/commons/1/17/RWS_Tarot_19_Sun.jpg', upright: 'å¿«ä¹ã€æˆåŠŸã€æ´»åŠ›', reversed: 'æš‚æ—¶çš„æ¶ˆæ²‰' },
    { id: 'judgement', name: 'Judgement (å®¡åˆ¤)', url: 'https://upload.wikimedia.org/wikipedia/commons/d/dd/RWS_Tarot_20_Judgement.jpg', upright: 'è§‰é†’ã€é‡ç”Ÿã€å†³å®š', reversed: 'è‡ªæˆ‘æ€€ç–‘ã€æ‹’ç»å¬å”¤' },
    { id: 'world', name: 'The World (ä¸–ç•Œ)', url: 'https://upload.wikimedia.org/wikipedia/commons/f/ff/RWS_Tarot_21_World.jpg', upright: 'å®Œæˆã€æ•´åˆã€æ—…è¡Œ', reversed: 'æœªå®Œæˆã€ç¼ºä¹é—­ç¯' }
];

// ================= æç®€çº¿æ¡å¡èƒŒçº¹ç† (No Glow) =================
function createMagicalBackTexture() {
    const canvas = document.createElement('canvas');
    canvas.width = 512;
    canvas.height = 896;
    const ctx = canvas.getContext('2d');
    const w = canvas.width;
    const h = canvas.height;

    // 1. èƒŒæ™¯ï¼šæ·±é‚ƒæ˜Ÿç©º + æå…‰çº¹ç†
    const grad = ctx.createRadialGradient(w/2, h/2, 50, w/2, h/2, h/0.8);
    grad.addColorStop(0, '#0a1a50');
    grad.addColorStop(0.5, '#05081a');
    grad.addColorStop(1, '#020308');
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, w, h);

    // æ·»åŠ ä¸€å±‚æ·¡æ·¡çš„æ˜Ÿäº‘æ„Ÿ
    for(let i=0; i<3; i++) {
        const x = Math.random() * w;
        const y = Math.random() * h;
        const r = 200 + Math.random() * 200;
        const g = ctx.createRadialGradient(x, y, 0, x, y, r);
        g.addColorStop(0, `rgba(100, 100, 255, 0.05)`);
        g.addColorStop(1, 'transparent');
        ctx.fillStyle = g;
        ctx.fillRect(0, 0, w, h);
    }

    // 1.5 ç²¾è‡´æ— ç¼çº¹ç† (Subtle Seamless Pattern)
    const patSize = 64;
    const patCanvas = document.createElement('canvas');
    patCanvas.width = patSize;
    patCanvas.height = patSize;
    const pCtx = patCanvas.getContext('2d');

    // ç»˜åˆ¶å¤å…¸è±æ ¼çº¹
    pCtx.lineWidth = 1;
    pCtx.strokeStyle = 'rgba(197, 160, 89, 0.05)'; // ææ·¡

    // è±å½¢
    pCtx.beginPath();
    pCtx.moveTo(patSize/2, 0);
    pCtx.lineTo(patSize, patSize/2);
    pCtx.lineTo(patSize/2, patSize);
    pCtx.lineTo(0, patSize/2);
    pCtx.closePath();
    pCtx.stroke();

    // ä¸­å¿ƒåå­—æ˜Ÿ
    pCtx.beginPath();
    pCtx.moveTo(patSize/2 - 5, patSize/2); pCtx.lineTo(patSize/2 + 5, patSize/2);
    pCtx.moveTo(patSize/2, patSize/2 - 5); pCtx.lineTo(patSize/2, patSize/2 + 5);
    pCtx.stroke();

    // äº¤å‰ç‚¹è£…é¥°
    pCtx.fillStyle = 'rgba(197, 160, 89, 0.08)';
    pCtx.beginPath();
    pCtx.arc(0, 0, 2, 0, Math.PI*2);
    pCtx.arc(patSize, 0, 2, 0, Math.PI*2);
    pCtx.arc(0, patSize, 2, 0, Math.PI*2);
    pCtx.arc(patSize, patSize, 2, 0, Math.PI*2);
    pCtx.fill();

    const pattern = ctx.createPattern(patCanvas, 'repeat');
    ctx.fillStyle = pattern;
    ctx.fillRect(0, 0, w, h);

    // 2. åä¸½å¤šé‡è¾¹æ¡†
    // æœ€å¤–å±‚é‡‘å±è¾¹
    ctx.strokeStyle = '#c5a059';
    ctx.lineWidth = 14;
    ctx.strokeRect(7, 7, w-14, h-14);
    
    // å†…å±‚ç»†é‡‘çº¿
    ctx.strokeStyle = '#ffd700';
    ctx.lineWidth = 1.5;
    ctx.strokeRect(25, 25, w-50, h-50);
    ctx.strokeRect(35, 35, w-70, h-70);

    // å››è§’è£…é¥°èŠ±çº¹
    const drawCorner = (cx, cy, rotation) => {
        ctx.save();
        ctx.translate(cx, cy);
        ctx.rotate(rotation);
        
        ctx.beginPath();
        // è±å½¢è£…é¥°
        ctx.moveTo(0, 0);
        ctx.lineTo(15, -15);
        ctx.lineTo(30, 0);
        ctx.lineTo(15, 15);
        ctx.closePath();
        
        // ä¸¤ä¾§çº¿æ¡
        ctx.moveTo(0, 0);
        ctx.lineTo(-20, 0);
        ctx.moveTo(0, 0);
        ctx.lineTo(0, -20);
        
        ctx.strokeStyle = 'rgba(197, 160, 89, 0.6)';
        ctx.lineWidth = 1.5;
        ctx.stroke();
        
        // å†…éƒ¨å¡«å……ç‚¹
        ctx.fillStyle = '#ffd700';
        ctx.beginPath();
        ctx.arc(15, 0, 2, 0, Math.PI*2);
        ctx.fill();
        
        ctx.restore();
    };

    drawCorner(50, 50, 0);
    drawCorner(w-50, 50, Math.PI/2);
    drawCorner(w-50, h-50, Math.PI);
    drawCorner(50, h-50, -Math.PI/2);

    // è¾¹ç¼˜ä¸­é—´è£…é¥°
    const drawSideDeco = (x, y, vertical) => {
        ctx.save();
        ctx.translate(x, y);
        if(vertical) ctx.rotate(Math.PI/2);
        
        ctx.beginPath();
        ctx.arc(0, 0, 3, 0, Math.PI*2);
        ctx.moveTo(-10, 0); ctx.lineTo(-25, 0);
        ctx.moveTo(10, 0); ctx.lineTo(25, 0);
        
        ctx.strokeStyle = 'rgba(197, 160, 89, 0.5)';
        ctx.lineWidth = 1;
        ctx.stroke();
        ctx.fill(); // é‡‘ç‚¹
        ctx.restore();
    };
    
    drawSideDeco(w/2, 42, false);  // Top
    drawSideDeco(w/2, h-42, false); // Bottom
    drawSideDeco(42, h/2, true);   // Left
    drawSideDeco(w-42, h/2, true);  // Right

    // 3. æ ¸å¿ƒè£…é¥°åŒº (å±…ä¸­)
    ctx.translate(w/2, h/2);
    
    // 3.1 æ ¸å¿ƒå‘å…‰æ„Ÿ
    const sunGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, 250);
    sunGrad.addColorStop(0, 'rgba(197, 160, 89, 0.25)');
    sunGrad.addColorStop(0.5, 'rgba(197, 160, 89, 0.05)');
    sunGrad.addColorStop(1, 'transparent');
    ctx.fillStyle = sunGrad;
    ctx.beginPath(); ctx.arc(0, 0, 250, 0, Math.PI*2); ctx.fill();

    // 3.2 24ç‚¹åä¸½æ˜Ÿè½®
    ctx.strokeStyle = '#ffd700';
    ctx.lineWidth = 1.5;
    ctx.shadowBlur = 15;
    ctx.shadowColor = '#ffd700'; // ç»™çº¿æ¡å¢åŠ å‘å…‰
    for (let i = 0; i < 24; i++) {
        ctx.rotate(Math.PI / 12);
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(0, i % 6 === 0 ? 220 : (i % 2 === 0 ? 170 : 120));
        ctx.stroke();
    }
    ctx.shadowBlur = 0; // é‡ç½®é˜´å½±ä»¥å…å½±å“åç»­
    
    // 3.3 è£…é¥°æ€§åˆ»åº¦åœ†ç¯
    ctx.lineWidth = 3;
    ctx.beginPath(); ctx.arc(0, 0, 85, 0, Math.PI*2); ctx.stroke();
    ctx.setLineDash([8, 12]);
    ctx.beginPath(); ctx.arc(0, 0, 110, 0, Math.PI*2); ctx.stroke();
    ctx.setLineDash([]);
    
    // 3.4 æœˆäº®ä¸æ ¸å¿ƒ (æäº®æ¨¡å¼)
    ctx.save();
    ctx.rotate(Math.PI / 4);
    ctx.shadowBlur = 40; // æ ¸å¿ƒè¶…å¼ºå‘å…‰
    ctx.shadowColor = '#fff0a0';
    ctx.fillStyle = '#ffffff'; // æ ¸å¿ƒæ”¹ä¸ºçº¯ç™½
    ctx.beginPath();
    ctx.arc(0, 0, 45, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.globalCompositeOperation = 'destination-out';
    ctx.beginPath();
    ctx.arc(20, -8, 45, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();

    // 4. æ˜Ÿåº§è¿çº¿ (æ·¡æ·¡çš„è£…é¥°èƒŒæ™¯)
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.strokeStyle = 'rgba(197, 160, 89, 0.15)';
    ctx.lineWidth = 0.5;
    const pts = [[100, 200], [150, 250], [80, 320], [200, 400], [400, 150], [350, 700], [120, 800]];
    ctx.beginPath();
    pts.forEach((p, i) => {
        if(i===0) ctx.moveTo(p[0], p[1]);
        else ctx.lineTo(p[0], p[1]);
        ctx.arc(p[0], p[1], 2, 0, Math.PI*2);
    });
    ctx.stroke();

    // 5. é«˜äº®æ˜Ÿå°˜
    for (let i = 0; i < 200; i++) {
        const size = Math.random() * 1.5;
        const alpha = Math.random() * 0.6 + 0.2;
        ctx.fillStyle = `rgba(255, 255, 200, ${alpha})`;
        ctx.beginPath();
        ctx.arc(Math.random() * w, Math.random() * h, size, 0, Math.PI * 2);
        ctx.fill();
    }

    const tex = new THREE.CanvasTexture(canvas);
    tex.anisotropy = renderer.capabilities.getMaxAnisotropy();
    return tex;
}

// ================= é­”æ³•å¡é¢ç€è‰²å™¨ (Magic Shader) =================
// å°†æ™®é€šå›¾ç‰‡å®æ—¶è½¬æ¢ä¸ºâ€œç´«é‡‘æµå…‰â€é£æ ¼
const MagicCardShader = {
    vertexShader: `
        varying vec2 vUv;
        varying vec3 vPosition;
        void main() {
            vUv = uv;
            vPosition = position;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    fragmentShader: `
        uniform sampler2D map;
        uniform vec3 colorDark;
        uniform vec3 colorLight;
        uniform vec3 colorAccent;
        uniform float time;
        varying vec2 vUv;
        varying vec3 vPosition;

        void main() {
            // 1. é‡‡æ ·åŸå›¾ (ç§»é™¤ç™½è¾¹)
            vec2 uv = (vUv - 0.5) * 0.94 + 0.5; 
            vec4 tex = texture2D(map, uv);
            
            // 2. æé«˜å¯¹æ¯”åº¦æ˜ å°„
            float gray = dot(tex.rgb, vec3(0.299, 0.587, 0.114));
            float contrast = smoothstep(0.05, 0.85, gray);
            
            // 3. æå…‰/åœ£å…‰é…è‰²
            vec3 deepBlue = vec3(0.02, 0.05, 0.2);
            vec3 goldBase = vec3(1.2, 0.95, 0.4); // è¶…è¿‡ 1.0 ä»¥äº§ç”Ÿè¿‡æ›æ„Ÿ
            vec3 finalColor = mix(deepBlue, goldBase, contrast);
            
            // 4. åŠ¨æ€è™¹å½©å¢å¼º
            float hueShift = sin(vUv.x * 6.0 + vUv.y * 4.0 + time * 2.0) * 0.5 + 0.5;
            vec3 rainbow = vec3(
                0.5 + 0.5 * cos(6.28 * (hueShift + 0.0)),
                0.5 + 0.5 * cos(6.28 * (hueShift + 0.33)),
                0.5 + 0.5 * cos(6.28 * (hueShift + 0.67))
            );
            
            // 5. æå¼ºæµå…‰ (Super Streak)
            float shimmer = sin(vUv.x * 5.0 + vUv.y * 2.0 + time * 3.0) * 0.5 + 0.5;
            float streak = pow(shimmer, 8.0) * 1.5; // å¼ºåº¦å¢åŠ 
            
            finalColor += rainbow * streak * contrast * 0.6;
            finalColor += vec3(1.0, 0.8, 0.3) * streak * contrast;

            // 6. æ ¸å¿ƒæ˜Ÿé’»é—ªçƒ (Diamond Sparkle)
            float glint = pow(max(0.0, sin(vUv.x * 25.0 + time * 2.0) * sin(vUv.y * 25.0 - time * 2.0)), 30.0);
            finalColor += vec3(1.0, 1.0, 0.9) * glint * contrast * 3.0;

            // 7. è¾¹ç¼˜åœ£å…‰
            float dist = distance(vUv, vec2(0.5));
            float glow = pow(dist, 3.5) * (0.4 + 0.15 * sin(time * 3.0));
            finalColor += vec3(0.8, 0.7, 1.0) * glow;

            gl_FragColor = vec4(finalColor, 1.0);
        }
    `
};

// ================= å…¨å±€å˜é‡ =================
let scene, camera, renderer;
let cardMesh = null;
let introCards = []; // Store intro deck meshes
let particles = [];
let deck = [...TAROT_DATA];
let isProcessingEffect = false;
let globalMaterials = null; // Store generated materials

// History data store (for reading replay)
let historyRecords = [];
let pendingNextCard = false;



// äº¤äº’çŠ¶æ€
const INTERACTION = {
    mode: 'hand', // 'hand' | 'mouse'
    state: 'INTRO', // 'INTRO', 'IDLE', 'HOVER', 'GRABBED', 'LOCKED'
    raycaster: new THREE.Raycaster(),
    pointer: new THREE.Vector2(), 
    targetPointer: new THREE.Vector2(), // ç›®æ ‡ä½ç½®ï¼Œç”¨äºå¹³æ»‘æ’å€¼
    gesture: 'NONE', 
    handPosition: new THREE.Vector3(),
    fistStartTime: 0 
};

// ================= è¾“å…¥ç®¡ç†å™¨ (MediaPipe + Mouse) =================
const inputManager = {
    videoElement: document.querySelector('.input_video'),
    hands: null,
    camera: null,
    _cameraStarting: false,

    init: async function() {
        console.log("æ­£åœ¨åˆå§‹åŒ–æ‰‹åŠ¿è¯†åˆ«ç³»ç»Ÿ...");
        document.getElementById('status-text').innerText = "æ­£åœ¨å¯åŠ¨æ˜Ÿç•Œæ„Ÿåº”ç³»ç»Ÿ...";
        
        // MediaPipe Setup
        try {
            this.hands = new Hands({locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }});
        } catch (err) {
            console.error("MediaPipe åº“åŠ è½½å¤±è´¥:", err);
            document.getElementById('status-text').innerText = "åº“æ–‡ä»¶åŠ è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œ";
            return;
        }
        
        this.hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 0, // é™ä½æ¨¡å‹å¤æ‚åº¦ä»¥æé«˜é€Ÿåº¦ (0=Lite, 1=Full)
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        this.hands.onResults(this.onHandsResults.bind(this));

        // å°è¯•å¯åŠ¨æ‘„åƒå¤´ï¼ˆå…ˆæ£€æŸ¥è®¾å¤‡ï¼Œé¿å… camera_utils åœ¨æ— æ‘„åƒå¤´æ—¶æŠ› NotFoundErrorï¼‰
        const ok = await this.startCamera();
        this.setMode(ok ? 'hand' : 'mouse');

        // Mouse Listeners
        const updatePointer = (clientX, clientY) => {
            INTERACTION.targetPointer.x = (clientX / window.innerWidth) * 2 - 1;
            INTERACTION.targetPointer.y = -(clientY / window.innerHeight) * 2 + 1;
        };

        window.addEventListener('mousemove', (e) => {
            if (INTERACTION.mode === 'mouse') {
                updatePointer(e.clientX, e.clientY);
                if (INTERACTION.state === 'IDLE' || INTERACTION.state === 'HOVER') {
                    INTERACTION.gesture = 'OPEN';
                }
            }
        });

        window.addEventListener('mousedown', (e) => {
            if (INTERACTION.mode === 'mouse' && !isProcessingEffect) {
                if (e.button === 0) INTERACTION.gesture = 'PINCH';
            }
        });

        window.addEventListener('mouseup', (e) => {
            if (INTERACTION.mode === 'mouse' && !isProcessingEffect) {
                if (INTERACTION.state === 'GRABBED') INTERACTION.gesture = 'OPEN';
            }
        });
        
        // Touch Support for Mobile
        window.addEventListener('touchmove', (e) => {
            if (INTERACTION.mode === 'mouse' && e.touches.length > 0) {
                e.preventDefault();
                updatePointer(e.touches[0].clientX, e.touches[0].clientY);
            }
        }, {passive: false});

        window.addEventListener('touchstart', (e) => {
            if (INTERACTION.mode === 'mouse' && e.touches.length > 0) {
                updatePointer(e.touches[0].clientX, e.touches[0].clientY);
                INTERACTION.gesture = 'PINCH';
            }
        }, {passive: false});

        window.addEventListener('touchend', () => {
            if (INTERACTION.mode === 'mouse') {
                if (INTERACTION.state === 'GRABBED') INTERACTION.gesture = 'OPEN';
                // æ¨¡æ‹ŸåŒå‡»æˆ–é•¿æŒ‰å¯èƒ½æ¯”è¾ƒå¤æ‚ï¼Œè¿™é‡Œç®€åŒ–ä¸ºæ¾å¼€å³æ”¾å¼€
            }
        });

        window.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            if (INTERACTION.mode === 'mouse' && INTERACTION.state === 'GRABBED') {
                INTERACTION.gesture = 'FIST'; // Right click confirms
            }
        });
    },

    startCamera: async function() {
        if (this._cameraStarting) return false;
        this._cameraStarting = true;
        try {
            // è®¾å¤‡é¢„æ£€ï¼šæ²¡æœ‰ videoinput å°±ç›´æ¥é™çº§ï¼Œä¸è§¦å‘ camera_utils çš„ NotFoundError log
            if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) {
                throw new Error("NO_MEDIA_DEVICES");
            }
            const devices = await navigator.mediaDevices.enumerateDevices().catch(() => []);
            const hasVideoInput = devices.some(d => d && d.kind === 'videoinput');
            if (!hasVideoInput) {
                throw new Error("NO_CAMERA_DEVICE");
            }

            let lastVideoTime = 0;
            const fpsInterval = 1000 / 20; // é™åˆ¶æ‰‹åŠ¿è¯†åˆ«ä¸º 20 FPS

            this.camera = new Camera(this.videoElement, {
                onFrame: async () => {
                    const now = Date.now();
                    if (now - lastVideoTime < fpsInterval) return;
                    lastVideoTime = now;
                    await this.hands.send({ image: this.videoElement });
                },
                width: 320,
                height: 240
            });
            await this.camera.start();
            return true;
        } catch (e) {
            console.warn("æ‘„åƒå¤´å¯åŠ¨å¤±è´¥ï¼Œå·²é™çº§é¼ æ ‡æ¨¡å¼ï¼š", e);
            const status = document.getElementById('status-text');
            if (String(e?.message || "").includes("NO_CAMERA_DEVICE")) {
                status.innerText = "æœªæ£€æµ‹åˆ°æ‘„åƒå¤´è®¾å¤‡ï¼Œå·²åˆ‡æ¢è‡³é¼ æ ‡æ¨¡å¼";
            } else {
                status.innerText = "æ‘„åƒå¤´ä¸å¯ç”¨/è¢«é˜»æ­¢ï¼Œå·²åˆ‡æ¢è‡³é¼ æ ‡æ¨¡å¼";
            }
            return false;
        } finally {
            this._cameraStarting = false;
        }
    },

    setMode: function(mode) {
        INTERACTION.mode = mode;
        document.getElementById('btn-mouse').className = mode === 'mouse' ? 'btn active' : 'btn';
        document.getElementById('btn-hand').className = mode === 'hand' ? 'btn active' : 'btn';
        
        const status = document.getElementById('status-text');
        if (mode === 'mouse') {
            status.innerText = "é¼ æ ‡æ¨¡å¼: å·¦é”®æ‹–æ‹½å¡ç‰Œï¼Œå³é”®ç¡®è®¤æŠ½å–";
            // Stop camera to save resources if explicitly switched
            if (this.videoElement.srcObject) {
               // this.videoElement.srcObject.getTracks().forEach(track => track.stop());
            }
        } else {
            status.innerText = "æ‰‹åŠ¿æ¨¡å¼: å¼ å¼€=ç§»åŠ¨ | æåˆ=æŠ“å– | æ¡æ‹³=ç¡®è®¤";
            // è‹¥ä¹‹å‰é™çº§è¿‡ï¼Œåˆ‡å›æ‰‹åŠ¿æ—¶å°è¯•é‡è¯•æ‘„åƒå¤´
            if (!this.camera) {
                status.innerText = "æ­£åœ¨å¯åŠ¨æ‘„åƒå¤´...";
                this.startCamera().then(ok => {
                    if (!ok) this.setMode('mouse');
                });
            }
        }
    },

    onHandsResults: function(results) {
        if (INTERACTION.mode !== 'hand') return;

        const pointerEl = document.getElementById('hand-pointer');
        
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const landmarks = results.multiHandLandmarks[0];
            
            // 1. Calculate Target Pointer (Index Tip)
            const indexTip = landmarks[8];
            // ä½¿ç”¨ targetPointer å­˜å‚¨åŸå§‹æ•°æ®ï¼Œåœ¨ animate ä¸­å¹³æ»‘å¤„ç†
            INTERACTION.targetPointer.x = -((indexTip.x * 2) - 1); 
            INTERACTION.targetPointer.y = -(indexTip.y * 2) + 1;

            // Update Visual Pointer (DOM updates are expensive, keep them minimal)
            pointerEl.style.display = 'block';
            pointerEl.style.left = `${(1 - indexTip.x) * 100}%`;
            pointerEl.style.top = `${indexTip.y * 100}%`;

            // 2. Gesture Recognition
            this.recognizeGesture(landmarks);
            
            // Update pointer visual state
            pointerEl.className = INTERACTION.gesture.toLowerCase();
            
        } else {
            INTERACTION.gesture = 'NONE';
            pointerEl.style.display = 'none';
        }
    },

    recognizeGesture: function(landmarks) {
        const wrist = landmarks[0];
        const thumbTip = landmarks[4];
        const indexTip = landmarks[8];
        const middleTip = landmarks[12];
        const ringTip = landmarks[16];
        const pinkyTip = landmarks[20];
        
        const indexPip = landmarks[6];
        const middlePip = landmarks[10];
        const ringPip = landmarks[14];
        const pinkyPip = landmarks[18];

        // åŸºç¡€æ‰‹æŒå¤§å°å‚è€ƒ (è…•éƒ¨åˆ°ä¸­æŒ‡æ ¹éƒ¨çš„è·ç¦»)
        const middleMcp = landmarks[9];
        const handSize = Math.hypot(wrist.x - middleMcp.x, wrist.y - middleMcp.y);

        // Normalized distance between thumb and index tip
        const pinchDist = Math.hypot(thumbTip.x - indexTip.x, thumbTip.y - indexTip.y);

        const isFingerExtended = (tip, pip) => {
            const dTip = Math.hypot(tip.x - wrist.x, tip.y - wrist.y);
            const dPip = Math.hypot(pip.x - wrist.x, pip.y - wrist.y);
            return dTip > dPip;
        };

        const iExt = isFingerExtended(indexTip, indexPip);
        const mExt = isFingerExtended(middleTip, middlePip);
        const rExt = isFingerExtended(ringTip, ringPip);
        const pExt = isFingerExtended(pinkyTip, pinkyPip);

        // 1. FIST: All fingers folded relative to their PIPs
        if (!iExt && !mExt && !rExt && !pExt) {
            INTERACTION.gesture = 'FIST';
            return;
        }

        // 2. PINCH: Thumb very close to index tip relative to hand size
        if (pinchDist < handSize * 0.4) {
            INTERACTION.gesture = 'PINCH';
            return;
        }

        // 3. OPEN: Default if index is extended
        if (iExt) {
            INTERACTION.gesture = 'OPEN';
            return;
        }

        INTERACTION.gesture = 'NONE';
    }
};

// ================= Three.js é€»è¾‘ =================
function initScene() {
    scene = new THREE.Scene();
    // Fog for depth
    scene.fog = new THREE.FogExp2(0x111111, 0.02);

    camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.z = 5;

    renderer = new THREE.WebGLRenderer({ antialias: window.devicePixelRatio < 2, alpha: true, powerPreference: "high-performance" });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    document.getElementById('canvas-container').appendChild(renderer.domElement);

    // Lights removed

    // æ˜Ÿç©ºèƒŒæ™¯ (Stars)
    addStarField();

    // Generate Textures
    const magicalTex = createMagicalBackTexture();
    globalMaterials = {
        back: new THREE.MeshBasicMaterial({
            map: magicalTex
        }),
        side: new THREE.MeshBasicMaterial({
            color: 0x0a1540
        })
    };

    // 4. Background Aura (Persistent)
    const auraMesh = createAuraMesh();
    scene.add(auraMesh);
    scene.userData.aura = auraMesh;

    // Start with Intro Deck
    spawnDeckIntro();
    
    // 3D Background Decor: Zodiac Wheel
    const zodiacWheel = createZodiacWheel();
    zodiacWheel.position.set(0, -3.5, -5);
    zodiacWheel.rotation.x = -Math.PI / 2.2;
    scene.add(zodiacWheel);
    scene.userData.zodiacWheel = zodiacWheel;

    // Hide loader
    document.getElementById('loader').style.opacity = 0;
    setTimeout(() => document.getElementById('loader').style.display = 'none', 500);

    animate();
}

function createAuraMesh() {
    const canvas = document.createElement('canvas');
    canvas.width = 256;
    canvas.height = 256;
    const ctx = canvas.getContext('2d');
    const grad = ctx.createRadialGradient(128, 128, 0, 128, 128, 128);
    grad.addColorStop(0, 'rgba(197, 160, 89, 0.6)');
    grad.addColorStop(0.4, 'rgba(157, 132, 255, 0.2)');
    grad.addColorStop(1, 'transparent');
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, 256, 256);
    
    const tex = new THREE.CanvasTexture(canvas);
    const geometry = new THREE.PlaneGeometry(8, 8);
    const material = new THREE.MeshBasicMaterial({ 
        map: tex, 
        transparent: true, 
        blending: THREE.AdditiveBlending,
        depthWrite: false
    });
    return new THREE.Mesh(geometry, material);
}

function updateAura(time) {
    if (!scene.userData.aura) return;
    const aura = scene.userData.aura;
    
    if (cardMesh && INTERACTION.state !== 'INTRO') {
        aura.visible = true;
        aura.position.copy(cardMesh.position);
        aura.position.z -= 0.1; // Place slightly behind
        const s = 1.2 + Math.sin(time * 2.0) * 0.1;
        aura.scale.set(s, s, 1);
        aura.material.opacity = 0.5 + Math.sin(time * 3.0) * 0.2;
    } else {
        aura.visible = false;
    }
}

function createZodiacWheel() {
    const canvas = document.createElement('canvas');
    canvas.width = 1024;
    canvas.height = 1024;
    const ctx = canvas.getContext('2d');
    const center = 512;
    
    ctx.strokeStyle = '#c5a059';
    ctx.lineWidth = 2;
    
    // Outer Rings
    for(let r of [500, 485, 410]) {
        ctx.beginPath();
        ctx.arc(center, center, r, 0, Math.PI*2);
        ctx.stroke();
    }
    
    // Zodiac Lines
    for(let i=0; i<12; i++) {
        const angle = (i/12) * Math.PI * 2;
        ctx.beginPath();
        ctx.moveTo(center + Math.cos(angle)*410, center + Math.sin(angle)*410);
        ctx.lineTo(center + Math.cos(angle)*500, center + Math.sin(angle)*500);
        ctx.stroke();
    }

    // Inner Decorative Pattern (Star Spokes)
    ctx.lineWidth = 1;
    for(let i=0; i<36; i++) {
        const angle = (i/36) * Math.PI * 2;
        ctx.beginPath();
        ctx.moveTo(center, center);
        ctx.lineTo(center + Math.cos(angle)*390, center + Math.sin(angle)*390);
        ctx.strokeStyle = `rgba(197, 160, 89, 0.2)`;
        ctx.stroke();
    }

    const tex = new THREE.CanvasTexture(canvas);
    const geometry = new THREE.PlaneGeometry(35, 35);
    const material = new THREE.MeshBasicMaterial({ 
        map: tex, 
        transparent: true, 
        opacity: 0.3,
        side: THREE.DoubleSide,
        depthWrite: false
    });
    return new THREE.Mesh(geometry, material);
}

function addStarField() {
    const starGeo = new THREE.BufferGeometry();
    const starCount = 1000;
    const pos = new Float32Array(starCount * 3);
    for(let i=0; i<starCount*3; i++) {
        pos[i] = (Math.random() - 0.5) * 100; // Large spread
    }
    starGeo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
    const starMat = new THREE.PointsMaterial({color: 0xffffff, size: 0.1, transparent: true, opacity: 0.8});
    const stars = new THREE.Points(starGeo, starMat);
    scene.add(stars);
}

// ================= ç‰Œé˜µé€»è¾‘ (åŠ¨æ€æ•°é‡ç‰ˆ) =================
function spawnDeckIntro() {
    INTERACTION.state = 'INTRO';
    isProcessingEffect = false; // é‡ç½®æ ‡è¯†ä½ï¼Œå…è®¸äº¤äº’
    
    if (deck.length === 0) {
        document.getElementById('status-text').innerText = "ç‰Œåº“å·²ç©ºï¼Œå‘½è¿å·²å®šã€‚";
        return;
    }

    document.getElementById('status-text').innerText = "æ»‘åŠ¨æ˜Ÿæ²³ï¼Œæ„Ÿåº”ä½ çš„ä¸‹ä¸€æ¬¡å‘½è¿ä¹‹ç‰Œ";

    // å®¹å™¨ Groupï¼Œç½®äºæ‘„åƒæœºä½ç½®ï¼Œå½¢æˆåŒ…å›´æ„Ÿ
    const deckGroup = new THREE.Group();
    deckGroup.position.copy(camera.position); 
    // ç»Ÿä¸€é«˜åº¦åç§»
    deckGroup.position.y -= 0.5; 
    scene.add(deckGroup);
    scene.userData.deckGroup = deckGroup;
    
    // å‰©ä½™ç‰Œæ•°ï¼Œæœ€å¤šæ˜¾ç¤º22å¼ 
    const count = Math.min(deck.length, 22); 
    const radius = 7.5; // å¢åŠ åŠå¾„ä»¥åŠ å®½é—´è·
    
    const geometry = new THREE.BoxGeometry(1.2, 2.1, 0.02);
    const materials = [
        globalMaterials.side, globalMaterials.side, 
        globalMaterials.side, globalMaterials.side, 
        globalMaterials.back, globalMaterials.back
    ];

    for (let i = 0; i < count; i++) {
        const mesh = new THREE.Mesh(geometry, materials);
        
        const angle = (i / count) * Math.PI * 2;
        
        // å®Œç¾çš„æ°´å¹³æ•´é½æ’åˆ—
        const x = Math.sin(angle) * radius;
        const z = -Math.cos(angle) * radius; 
        const y = 0; // å®¹å™¨å†…ç›¸å¯¹é«˜åº¦ä¸º0
        
        mesh.position.set(x, y, z);
        
        // è®©å¡ç‰Œé¢å‘åœ†å¿ƒ
        mesh.lookAt(camera.position.x, camera.position.y - 0.5, camera.position.z);
        
        mesh.userData = {
            introIndex: i,
            basePos: mesh.position.clone(),
            angle: angle
        };
        
        deckGroup.add(mesh);
        introCards.push(mesh);
    }
}

function updateIntroDeck() {
    if (INTERACTION.state !== 'INTRO') return;
    
    // 0. è®©ç‰Œé˜µå§‹ç»ˆè·Ÿéšæ‘„åƒæœºï¼ˆé¿å…è§†å·®/æ‰‹åŠ¿å¯¼è‡´ç›¸å¯¹ä½ç½®æ¼‚ç§»ï¼Œå‡ºç°â€œä¸ªåˆ«å¡æœå‘ä¸å¯¹â€ï¼‰
    if (scene.userData.deckGroup) {
        scene.userData.deckGroup.position.copy(camera.position);
        scene.userData.deckGroup.position.y -= 0.5;
    }

    // 1. æ—‹è½¬é€»è¾‘ï¼šé¼ æ ‡/æ‰‹åŠ¿æ§åˆ¶æ•´ä¸ªåœ†ç¯æ—‹è½¬
    if (scene.userData.deckGroup) {
        const baseSpeed = 0.0008; 
        const interactSpeed = INTERACTION.targetPointer.x * 0.035;
        scene.userData.deckGroup.rotation.y -= (baseSpeed + interactSpeed);
    }

    // 1.5 è®©æ¯å¼ å¡å§‹ç»ˆæœå‘ä¸­å¿ƒï¼ˆæ‘„åƒæœºï¼‰ï¼Œé¿å… group æ—‹è½¬åå‡ºç°â€œæ­ªå‘/èƒŒå‘â€
    if (scene.userData.deckGroup && introCards.length) {
        const target = camera.position.clone();
        target.y -= 0.5;
        introCards.forEach((mesh) => mesh.lookAt(target));
    }

    // 2. å°„çº¿æ£€æµ‹
    INTERACTION.raycaster.setFromCamera(INTERACTION.pointer, camera);
    const intersects = INTERACTION.raycaster.intersectObjects(introCards);
    
    let hoveredMesh = null;
    if (intersects.length > 0) {
        hoveredMesh = intersects[0].object;
        document.body.style.cursor = 'pointer';
        if (INTERACTION.gesture === 'PINCH') {
            selectIntroCard(hoveredMesh);
            return;
        }
    } else {
        document.body.style.cursor = 'default';
    }

    // 3. æ‚¬åœåŠ¨æ•ˆ
    introCards.forEach(mesh => {
        let targetScale = 1.0;
        let targetY = mesh.userData.basePos.y;

        if (mesh === hoveredMesh) {
            targetScale = 1.4; // æ‚¬åœç¨å¾®æ”¾å¤§æ›´å¤š
            targetY += 0.6;   // æ‚¬åœä¸Šæµ®æ›´æ˜æ˜¾
            if (mesh.material[5].emissive) {
                mesh.material[5].emissive.setHex(0x666666);
            }
        } else {
            // ç§»é™¤æ™®é€šçŠ¶æ€çš„æ³¢åŠ¨ï¼Œä¿æŒç»å¯¹æ•´é½
            if (mesh.material[5].emissive) {
                mesh.material[5].emissive.setHex(0x000000); 
            }
        }
        
        mesh.scale.setScalar(THREE.MathUtils.lerp(mesh.scale.x, targetScale, 0.15));
        mesh.position.y = THREE.MathUtils.lerp(mesh.position.y, targetY, 0.1);
    });
}

function selectIntroCard(selectedMesh) {
    if (isProcessingEffect) return;
    isProcessingEffect = true;
    
    // 1. ç§»é™¤å…¶ä»–å¡ç‰Œ (å‘å¤–é£æ•£æ¶ˆå¤±)
    introCards.forEach(mesh => {
        if (mesh !== selectedMesh) {
            const dir = mesh.position.clone().normalize();
            const animateOut = () => {
                mesh.position.add(dir.multiplyScalar(0.3)); // å‘å¤–é£
                mesh.material.forEach(m => {
                    if(m.transparent) m.opacity -= 0.05;
                });
                mesh.scale.multiplyScalar(0.9);
                
                if (mesh.scale.x < 0.1) {
                    if(mesh.parent) mesh.parent.remove(mesh);
                } else {
                    requestAnimationFrame(animateOut);
                }
            };
            animateOut();
        }
    });
    introCards = [];
    
    // 2. å°†é€‰ä¸­çš„å¡ç‰Œä» Group è½¬ç§»åˆ° Scene (ä¿æŒä¸–ç•Œåæ ‡)
    if (scene.userData.deckGroup) {
        const worldPos = new THREE.Vector3();
        const worldQuat = new THREE.Quaternion();
        selectedMesh.getWorldPosition(worldPos);
        selectedMesh.getWorldQuaternion(worldQuat);
        
        // Detach from parent and attach to scene root
        scene.attach(selectedMesh);
        
        scene.remove(scene.userData.deckGroup);
        scene.userData.deckGroup = null;
    }

    cardMesh = selectedMesh;
    
    // 3. ç”Ÿæˆå¡ç‰Œæ•°æ®
    if (deck.length === 0) return;
    const index = Math.floor(Math.random() * deck.length);
    const cardData = deck[index];
    deck.splice(index, 1);
    
    const isReversed = Math.random() < 0.5;
    
    // Load Front Texture
    const loader = new THREE.TextureLoader();
    const texFront = loader.load(cardData.url, (tex) => {
        tex.center.set(0.5, 0.5);
        
        // Use Magic Shader Material instead of Standard
        const matFront = new THREE.ShaderMaterial({
            uniforms: {
                map: { value: tex },
                colorDark: { value: new THREE.Color('#1a103c') }, // æ·±ç´«èƒŒæ™¯
                colorLight: { value: new THREE.Color('#ffd700') }, // é‡‘è‰²çº¿æ¡
                colorAccent: { value: new THREE.Color('#fff0a0') }, // é«˜å…‰
                time: { value: 0 }
            },
            vertexShader: MagicCardShader.vertexShader,
            fragmentShader: MagicCardShader.fragmentShader
        });
        
        // Save reference to animate time
        if(!cardMesh.userData.shaderMats) cardMesh.userData.shaderMats = [];
        cardMesh.userData.shaderMats.push(matFront);

        cardMesh.material = [
            cardMesh.material[0], cardMesh.material[1], 
            cardMesh.material[2], cardMesh.material[3], 
            matFront, 
            cardMesh.material[5]
        ];
    });

    // Store Game Data
    cardMesh.userData = {
        data: cardData,
        isReversed: isReversed,
        velocity: new THREE.Vector3(),
    };
    
    // Animate to Center
    const startPos = cardMesh.position.clone();
    const startRot = cardMesh.rotation.clone();
    const startTime = Date.now();
    
    const animateToCenter = () => {
        const now = Date.now();
        const progress = Math.min((now - startTime) / 1000, 1);
        const ease = 1 - Math.pow(1 - progress, 3); // Cubic out
        
        cardMesh.position.lerpVectors(startPos, new THREE.Vector3(0, 0, 0), ease);
        // Rotate to standard upright back-facing first
        // Intro cards are roughly facing Z- but rotated.
        // We want final state: IDLE (floating, back visible -> rot Y = PI)
        
        // Quaternions would be better but let's use Euler lerp for simplicity here
        cardMesh.rotation.x = THREE.MathUtils.lerp(startRot.x, 0, ease);
        cardMesh.rotation.y = THREE.MathUtils.lerp(startRot.y, Math.PI, ease); // Face back
        cardMesh.rotation.z = THREE.MathUtils.lerp(startRot.z, 0, ease);
        
        // Scale to normal - Keep it elegant
        cardMesh.scale.setScalar(1.0); 
        
        if (progress < 1) {
            requestAnimationFrame(animateToCenter);
        } else {
            // Done
            INTERACTION.state = 'IDLE';
            isProcessingEffect = false;
            document.getElementById('status-text').innerText = "å·²æ„Ÿåº”ã€‚ç‚¹å‡»/æåˆæŠ“å–æŸ¥çœ‹";
        }
    };
    animateToCenter();
}

// NOTE: `spawnCard()` å·²åºŸå¼ƒï¼ˆå½“å‰æŠ½å–éƒ½é€šè¿‡ç¯ç»•ç‰Œé˜µé€‰æ‹©ï¼‰

// ================= ç²’å­ç°çƒ¬æ•ˆæœ -> æ”¹ä¸ºï¼šæ˜Ÿå…‰è§£ä½“ (Stardust Dissolve) =================
function createAshEffect(position) {
    const particleCount = 1500;
    const geometry = new THREE.BufferGeometry();
    const positions = [];
    const velocities = [];
    const colors = [];
    const sizes = [];

    const baseColor = new THREE.Color('#ffd700');
    const accentColor = new THREE.Color('#ffffff');

    // Create particles within the card's bounding box
    for (let i = 0; i < particleCount; i++) {
        // Random pos within roughly card size (1.2 x 2.1)
        const px = position.x + (Math.random() - 0.5) * 1.2;
        const py = position.y + (Math.random() - 0.5) * 2.1;
        const pz = position.z + (Math.random() - 0.5) * 0.1;
        positions.push(px, py, pz);

        // Velocity: Explode outwards gently + drift up
        const speed = 0.02 + Math.random() * 0.03;
        const angle = Math.random() * Math.PI * 2;
        const rise = Math.random() * 0.05 + 0.01;
        
        velocities.push(
            Math.cos(angle) * speed, // x
            rise,                    // y (up)
            Math.sin(angle) * speed  // z
        );

        // Color: Mix of Gold and White
        const col = Math.random() > 0.3 ? baseColor : accentColor;
        colors.push(col.r, col.g, col.b);

        sizes.push(Math.random() * 0.15 + 0.05); // Larger, glowing particles
    }

    geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
    geometry.setAttribute('velocity', new THREE.Float32BufferAttribute(velocities, 3));
    geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
    geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));

    // Custom Shader Material for glowing particles
    const material = new THREE.PointsMaterial({
        vertexColors: true,
        size: 0.1,
        transparent: true,
        opacity: 1.0,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
        map: getParticleTexture() // Soft glow texture (cached)
    });

    const particleSystem = new THREE.Points(geometry, material);
    particleSystem.userData = { life: 120 }; // frames
    scene.add(particleSystem);
    particles.push(particleSystem);
}

// Helper: Cached soft glow texture for particles
let _particleTex = null;
function getParticleTexture() {
    if (_particleTex) return _particleTex;
    const canvas = document.createElement('canvas');
    canvas.width = 32;
    canvas.height = 32;
    const ctx = canvas.getContext('2d');
    const grad = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
    grad.addColorStop(0, 'rgba(255, 255, 255, 1)');
    grad.addColorStop(0.4, 'rgba(255, 215, 0, 0.5)');
    grad.addColorStop(1, 'rgba(0, 0, 0, 0)');
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, 32, 32);
    _particleTex = new THREE.CanvasTexture(canvas);
    return _particleTex;
}

// ================= è§£è¯»ï¼ˆReadingï¼‰ =================
const API_CONFIG = {
    // 1. é…ç½®ä½ çš„ API Key (å›½å†…ä¸­è½¬ã€DeepSeekã€GPTç­‰)
    key: "sk-otrhhbpeovbxunzrjvvdxmjpjeeykhpkjfqbinlxnrvkwjbz", 
    // 2. é…ç½®æ¥å£åœ°å€ (ä¾‹å¦‚ https://api.deepseek.com/v1/chat/completions)
    endpoint: "https://api.siliconflow.cn/v1/chat/completions", 
    // 3. æ¨¡å‹åç§° (ä¾‹å¦‚ deepseek-chat, gpt-3.5-turbo ç­‰)
    modelName: "deepseek-ai/DeepSeek-V3",
    // 4. æ¥å£æ ¼å¼ï¼štrue ä½¿ç”¨ OpenAI æ ¼å¼ (DeepSeek/GPT), false ä½¿ç”¨ Gemini æ ¼å¼
    isOpenAI: true 
};

async function fetchAIInterpretation(record) {
    const { name, isReversed, meaning } = record;
    const bodyEl = document.getElementById('reading-body');
    const orientation = isReversed ? "é€†ä½" : "æ­£ä½";
    
    // Add loading indicator
    const aiSectionId = `ai-reading-${record.ts}`;
    const old = document.getElementById(aiSectionId);
    if (old) old.remove();
    const aiSection = document.createElement('div');
    aiSection.id = aiSectionId;
    aiSection.innerHTML = `
        <div class="ai-header">âœ¨ AI ORACLE DECODING <span class="loading-dots"></span></div>
        <div class="ai-content" style="opacity: 0.6; font-style: italic;">æ­£åœ¨è½¬è¯‘æ˜Ÿç•Œä¿¡å·...</div>
    `;
    bodyEl.appendChild(aiSection);

    const ctx = record.aiPromptContext || loadAIContext();
    record.aiPromptContext = ctx;
    const prompt = buildAIPrompt({ name, orientation, meaning }, ctx);

    try {
        if (!API_CONFIG.key || API_CONFIG.key.includes("ä½ çš„")) {
            throw new Error("è¯·å…ˆåœ¨ API_CONFIG.key é…ç½®ä½ çš„ API Key");
        }

        let result = "";
        if (API_CONFIG.isOpenAI) {
            // --- OpenAI å…¼å®¹æ ¼å¼ (é€‚ç”¨äº DeepSeek, é€šä¹‰åƒé—®, GPT ç­‰) ---
            const response = await fetch(API_CONFIG.endpoint, {
                method: 'POST',
                headers: { 
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${API_CONFIG.key}`
                },
                body: JSON.stringify({
                    model: API_CONFIG.modelName,
                    messages: [{ role: "user", content: prompt }]
                })
            });
            const data = await response.json();
            if (!response.ok) throw new Error(data.error?.message || `HTTP ${response.status}`);
            result = data.choices[0].message.content;
        } else {
            // --- Gemini æ ¼å¼ (é€‚ç”¨äºå›½å†…çš„ Gemini ä¸­è½¬åœ°å€) ---
            const response = await fetch(`${API_CONFIG.endpoint}?key=${API_CONFIG.key}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    contents: [{ parts: [{ text: prompt }] }]
                })
            });
            const data = await response.json();
            if (!response.ok) throw new Error(data.error?.message || `HTTP ${response.status}`);
            result = data.candidates[0].content.parts[0].text;
        }

        const contentEl = aiSection.querySelector('.ai-content');
        contentEl.style.opacity = "1";
        contentEl.style.fontStyle = "normal";
        contentEl.innerText = result;
        
        const dots = aiSection.querySelector('.loading-dots');
        if(dots) dots.remove();
        record.aiInterpretation = result;

    } catch (error) {
        console.error("AI Error:", error);
        aiSection.querySelector('.ai-content').innerHTML = `<span style="color: #ff4d4d;">ï¼ˆæ˜Ÿç•Œé€šè®¯å¤±è´¥ï¼š${error.message}ï¼‰</span>`;
        const dots = aiSection.querySelector('.loading-dots');
        if(dots) dots.remove();
    }
}

// ===== AI Prompt Context =====
const AI_CONTEXT_DEFAULT = {
    question: "",
    domain: "é€šç”¨",
    timeHorizon: "7å¤©"
};

function loadAIContext() {
    try {
        const raw = localStorage.getItem('tarot_ai_ctx');
        if (!raw) return { ...AI_CONTEXT_DEFAULT };
        const parsed = JSON.parse(raw);
        return {
            question: String(parsed.question || ""),
            domain: String(parsed.domain || "é€šç”¨"),
            timeHorizon: String(parsed.timeHorizon || "7å¤©")
        };
    } catch {
        return { ...AI_CONTEXT_DEFAULT };
    }
}

function saveAIContext(ctx) {
    try {
        localStorage.setItem('tarot_ai_ctx', JSON.stringify(ctx));
    } catch {}
}

function buildAIPrompt(card, ctx) {
    const q = (ctx.question || "").trim();
    const domain = ctx.domain || "é€šç”¨";
    const horizon = ctx.timeHorizon || "7å¤©";

    const questionLine = q ? `æˆ‘çš„é—®é¢˜/ä¸»é¢˜ï¼š${q}` : `æˆ‘çš„é—®é¢˜/ä¸»é¢˜ï¼šæœªæä¾›ï¼ˆè¯·ç»™å‡ºé€šç”¨æŒ‡å¯¼ï¼‰`;

    return [
        "ä½ æ˜¯ä¸€ä½ä¸“ä¸šå¡”ç½—å åœå¸ˆä¸å’¨è¯¢æ•™ç»ƒã€‚è¯·åŸºäºæŠ½åˆ°çš„ç‰Œç»™å‡ºâ€œæŒ‡å¯¼æ€§è§£è¯»â€ï¼Œé‡ç‚¹æ˜¯å¸®åŠ©æˆ‘åšå†³å®šä¸è¡ŒåŠ¨ï¼Œè€Œä¸æ˜¯ç„å­¦æ–­è¨€ã€‚",
        "",
        `ç‰Œï¼š${card.name}ï¼ˆ${card.orientation}ï¼‰`,
        `æ ¸å¿ƒç‰Œæ„ï¼š${card.meaning}`,
        questionLine,
        `é¢†åŸŸï¼š${domain}`,
        `æ—¶é—´èŒƒå›´ï¼š${horizon}`,
        "",
        "è¾“å‡ºè¦æ±‚ï¼ˆå¿…é¡»æŒ‰ä»¥ä¸‹ç»“æ„ï¼‰ï¼š",
        "1ï¼‰ä¸€å¥è¯ä¸»é¢˜ï¼šç‚¹å‡ºæˆ‘å½“ä¸‹æœ€éœ€è¦é¢å¯¹çš„æ ¸å¿ƒè¯¾é¢˜ã€‚",
        "2ï¼‰ç°çŠ¶æ´å¯Ÿï¼šæŠŠç‰Œæ„è½åˆ°æˆ‘çš„å¤„å¢ƒï¼ˆå…·ä½“ã€è´´è¿‘ç°å®ï¼‰ã€‚",
        "3ï¼‰ç›²ç‚¹/é˜»ç¢ï¼šæŒ‡å‡º 1-2 ä¸ªæˆ‘å¯èƒ½å¿½ç•¥çš„å…³é”®ç‚¹ã€‚",
        "4ï¼‰è¡ŒåŠ¨å»ºè®®ï¼ˆæœ€é‡è¦ï¼‰ï¼šç»™ 3 æ¡å¯æ‰§è¡Œå»ºè®®ï¼Œæ¯æ¡åŒ…å«â€œå…·ä½“åŠ¨ä½œ + é€‚ç”¨åœºæ™¯ + æ—¶é—´èŒƒå›´â€ã€‚",
        "5ï¼‰åæ€æé—®ï¼šç»™æˆ‘ 2 ä¸ªé«˜è´¨é‡è‡ªé—®å¥ã€‚",
        "",
        "é£æ ¼ï¼šæ¸©æŸ”ä½†ä¸å«ç³Šï¼›å°‘é¸¡æ±¤ï¼Œå¤šè½åœ°ï¼›ä¸è¦ä¿è¯ç»“æœï¼Œä¸è¦ç®—å‘½å¼æ–­è¨€ï¼›é¿å…åŒ»ç–—/æ³•å¾‹/æŠ•èµ„ç­‰ä¸“ä¸šç»“è®ºã€‚",
        "å­—æ•°ï¼š180-260å­—ã€‚"
    ].join("\n");
}

function buildReading(record) {
    const { name, isReversed, meaning, ts } = record;
    const orientation = isReversed ? "é€†ä½" : "æ­£ä½";
    const timeStr = new Date(ts).toLocaleString();

    const chips = [
        `<span class="reading-chip">è§£è¯»æ—¶é—´ï¼š${timeStr}</span>`,
        `<span class="reading-chip">å–å‘ï¼š${orientation}</span>`
    ].join("");

    const html = `
        ${chips}
        <h4>ç‰Œæ„ï¼ˆ${orientation}ï¼‰</h4>
        <p>${meaning}</p>
    `;

    const plain = [
        `ã€${name}ï½œ${orientation}ã€‘`,
        `æ—¶é—´ï¼š${timeStr}`,
        "",
        `æ ¸å¿ƒç‰Œæ„ï¼š`,
        meaning
    ].join("\n");

    return { html, plain, orientation };
}

function openReading(recordIndex) {
    const record = historyRecords[recordIndex];
    if (!record) return;

    const panel = document.getElementById('reading-panel');
    const nameEl = document.getElementById('reading-name');
    const orientEl = document.getElementById('reading-orientation');
    const bodyEl = document.getElementById('reading-body');

    const reading = buildReading(record);
    nameEl.textContent = record.name;
    orientEl.textContent = reading.orientation;
    bodyEl.innerHTML = reading.html;

    // AI Context UI (prompt variables)
    const ctx = record.aiPromptContext || loadAIContext();
    record.aiPromptContext = ctx;
    const ctxEl = document.createElement('div');
    ctxEl.className = 'ai-context';
    ctxEl.innerHTML = `
        <div class="ai-context-title">
            <span>AI æé—®è®¾ç½®ï¼ˆå¯é€‰ï¼‰</span>
            <button class="btn btn-mini btn-ghost" id="btn-ai-regenerate">é‡æ–°ç”ŸæˆAI</button>
        </div>
        <div class="ai-fields">
            <div class="ai-field" style="grid-column: 1 / -1;">
                <div class="ai-label">é—®é¢˜ / ä¸»é¢˜</div>
                <textarea class="ai-input" id="ai-question" placeholder="ä¾‹å¦‚ï¼šæˆ‘è¯¥ä¸è¯¥æ¢å·¥ä½œï¼Ÿè¿™æ®µå…³ç³»æ˜¯å¦è¦ç»§ç»­ï¼Ÿ">${escapeHtml(ctx.question || "")}</textarea>
            </div>
            <div class="ai-field">
                <div class="ai-label">é¢†åŸŸ</div>
                <select class="ai-select" id="ai-domain">
                    ${renderOptions(["é€šç”¨","æ„Ÿæƒ…","äº‹ä¸š","å­¦ä¸š","è´¢åŠ¡","äººé™…","å¥åº·","è‡ªæˆ‘æˆé•¿"], ctx.domain || "é€šç”¨")}
                </select>
            </div>
            <div class="ai-field">
                <div class="ai-label">æ—¶é—´èŒƒå›´</div>
                <select class="ai-select" id="ai-horizon">
                    ${renderOptions(["48å°æ—¶","7å¤©","30å¤©","3ä¸ªæœˆ"], ctx.timeHorizon || "7å¤©")}
                </select>
            </div>
        </div>
    `;
    bodyEl.appendChild(ctxEl);

    panel.classList.remove('hidden');
    panel.dataset.activeIndex = String(recordIndex);

    // Wire context inputs
    const qEl = document.getElementById('ai-question');
    const dEl = document.getElementById('ai-domain');
    const hEl = document.getElementById('ai-horizon');
    const btnRegen = document.getElementById('btn-ai-regenerate');

    const syncCtx = () => {
        const newCtx = {
            question: String(qEl?.value || ""),
            domain: String(dEl?.value || "é€šç”¨"),
            timeHorizon: String(hEl?.value || "7å¤©")
        };
        record.aiPromptContext = newCtx;
        saveAIContext(newCtx);
    };
    qEl?.addEventListener('input', syncCtx);
    dEl?.addEventListener('change', syncCtx);
    hEl?.addEventListener('change', syncCtx);
    btnRegen?.addEventListener('click', () => {
        syncCtx();
        record.aiInterpretation = null;
        fetchAIInterpretation(record);
    });

    // Trigger AI interpretation if not already present
    if (!record.aiInterpretation) {
        fetchAIInterpretation(record);
    } else {
        // Show cached AI reading
        const aiSection = document.createElement('div');
        aiSection.innerHTML = `
            <div class="ai-header">âœ¨ AI ORACLE DECODING</div>
            <div class="ai-content">${record.aiInterpretation}</div>
        `;
        bodyEl.appendChild(aiSection);
    }
}

function escapeHtml(s) {
    return String(s)
        .replaceAll('&', '&amp;')
        .replaceAll('<', '&lt;')
        .replaceAll('>', '&gt;')
        .replaceAll('"', '&quot;')
        .replaceAll("'", '&#39;');
}

function renderOptions(options, selected) {
    return options.map(v => `<option value="${escapeHtml(v)}"${v === selected ? ' selected' : ''}>${escapeHtml(v)}</option>`).join('');
}

async function copyReading() {
    const panel = document.getElementById('reading-panel');
    const idx = Number(panel.dataset.activeIndex);
    const record = historyRecords[idx];
    if (!record) return;
    const reading = buildReading(record);

    let textToCopy = reading.plain;
    if (record.aiInterpretation) {
        textToCopy += `\n\nAI æ·±åº¦è§£è¯»ï¼š\n${record.aiInterpretation}`;
    }

    try {
        await navigator.clipboard.writeText(textToCopy);
        document.getElementById('status-text').innerText = "å·²å¤åˆ¶è§£è¯»åˆ°å‰ªè´´æ¿";
    } catch (e) {
        window.prompt("å¤åˆ¶å¤±è´¥ï¼Œè¯·æ‰‹åŠ¨å¤åˆ¶ï¼š", textToCopy);
    }
}

function updateParticles() {
    for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.userData.life--;

        const positions = p.geometry.attributes.position.array;
        const velocities = p.geometry.attributes.velocity.array;
        
        for (let j = 0; j < positions.length / 3; j++) {
            // Update Pos
            positions[j * 3] += velocities[j * 3];     // x
            positions[j * 3 + 1] += velocities[j * 3 + 1]; // y
            positions[j * 3 + 2] += velocities[j * 3 + 2]; // z

            // Drag (slow down explosion)
            velocities[j * 3] *= 0.98;
            velocities[j * 3 + 2] *= 0.98;
        }

        p.geometry.attributes.position.needsUpdate = true;
        
        // Life fade
        const alpha = p.userData.life / 120;
        p.material.opacity = alpha;
        
        if (p.userData.life <= 0) {
            scene.remove(p);
            p.geometry.dispose();
            p.material.dispose();
            particles.splice(i, 1);
        }
    }
}

// ================= ä¸»å¾ªç¯ä¸äº¤äº’é€»è¾‘ =================
function updateInteraction() {
    // Smooth pointer movement
    INTERACTION.pointer.lerp(INTERACTION.targetPointer, 0.2);

    // Intro Deck Logic
    if (INTERACTION.state === 'INTRO') {
        updateIntroDeck();
        return;
    }

    if (!cardMesh || isProcessingEffect) return;

    INTERACTION.raycaster.setFromCamera(INTERACTION.pointer, camera);
    const intersects = INTERACTION.raycaster.intersectObject(cardMesh);
    const isHovered = intersects.length > 0;

    // State Machine
    const chargeBarContainer = document.getElementById('charge-bar-container');
    const chargeBar = document.getElementById('charge-bar');

    // Parallax Effect: Camera moves slightly opposite to pointer
    const parallaxX = INTERACTION.pointer.x * 0.5;
    const parallaxY = INTERACTION.pointer.y * 0.5;
    camera.position.x += (parallaxX - camera.position.x) * 0.1;
    camera.position.y += (parallaxY - camera.position.y) * 0.1;
    camera.lookAt(0, 0, 0);

    switch (INTERACTION.state) {
        case 'IDLE':
            chargeBarContainer.style.opacity = 0;
            // Float animation
            const time = Date.now() * 0.001;
            cardMesh.position.y = Math.sin(time) * 0.2;
            cardMesh.rotation.y = THREE.MathUtils.lerp(cardMesh.rotation.y, Math.PI, 0.1); 

            if (isHovered && INTERACTION.gesture === 'PINCH') {
                INTERACTION.state = 'GRABBED';
                document.getElementById('status-text').innerText = "é•¿æŒ‰æ¡æ‹³ / å³é”®è“„åŠ›ç¡®è®¤";
            } else if (isHovered) {
                cardMesh.scale.setScalar(1.05);
                document.body.style.cursor = 'pointer';
            } else {
                cardMesh.scale.setScalar(1.0);
                document.body.style.cursor = 'default';
            }
            break;

        case 'GRABBED':
            // Move card to pointer projection with smooth follow
            const targetZ = 2.0; 
            const vec = new THREE.Vector3(INTERACTION.pointer.x, INTERACTION.pointer.y, 0.5);
            vec.unproject(camera);
            const dir = vec.sub(camera.position).normalize();
            const distance = (targetZ - camera.position.z) / dir.z;
            const pos = camera.position.clone().add(dir.multiplyScalar(distance));
            
            // Add slight "weight" lag - Snappier follow
            cardMesh.position.lerp(pos, 0.2);

            // Rotate to face front
            const targetRotZ = cardMesh.userData.isReversed ? Math.PI : 0;
            cardMesh.rotation.x = THREE.MathUtils.lerp(cardMesh.rotation.x, 0, 0.1);
            cardMesh.rotation.y = THREE.MathUtils.lerp(cardMesh.rotation.y, 0, 0.1);
            cardMesh.rotation.z = THREE.MathUtils.lerp(cardMesh.rotation.z, targetRotZ, 0.1);

            // (no lights)

            // Charge Logic (FIST)
            if (INTERACTION.gesture === 'FIST') {
                if (INTERACTION.fistStartTime === 0) INTERACTION.fistStartTime = Date.now();
                
                const duration = Date.now() - INTERACTION.fistStartTime;
                const progress = Math.min(duration / 1000, 1.0); // 1.0s to confirm
                
                // Visual feedback: Shake
                const shakeIntensity = 0.05 * progress;
                cardMesh.position.x += (Math.random() - 0.5) * shakeIntensity;
                cardMesh.position.y += (Math.random() - 0.5) * shakeIntensity;
                
                // UI feedback
                chargeBarContainer.style.opacity = 1;
                chargeBar.style.width = `${progress * 100}%`;
                
                if (progress >= 1.0) {
                    confirmSelection();
                    chargeBarContainer.style.opacity = 0;
                }
            } else {
                // Reset charge if released
                INTERACTION.fistStartTime = 0;
                chargeBarContainer.style.opacity = 0;
                chargeBar.style.width = '0%';
                
                if (INTERACTION.gesture === 'OPEN') {
                    INTERACTION.state = 'IDLE';
                    document.getElementById('status-text').innerText = "å·²æ¾å¼€";
                }
            }
            break;
    }
}

function confirmSelection() {
    if (isProcessingEffect) return;
    isProcessingEffect = true;
    INTERACTION.state = 'LOCKED';

    const data = cardMesh.userData.data;
    const isRev = cardMesh.userData.isReversed;
    const meaning = isRev ? data.reversed : data.upright;
    const statusStr = isRev ? "(é€†ä½)" : "(æ­£ä½)";

    // Store history record
    const recordIndex = historyRecords.length;
    historyRecords.push({
        name: data.name,
        isReversed: isRev,
        meaning,
        ts: Date.now()
    });

    // Update UI History
    const historyPanel = document.getElementById('history-panel');
    const item = document.createElement('div');
    item.className = 'history-item';
    item.dataset.recordIndex = String(recordIndex);
    item.title = "ç‚¹å‡»æŸ¥çœ‹è§£è¯»";
    
    // Modern tag style
    const revTag = isRev ? `<span class="reversed-tag">R</span>` : '';
    
    item.innerHTML = `
        <div class="history-name">${data.name} ${revTag}</div>
        <div class="history-meaning">${meaning}</div>
    `;
    historyPanel.prepend(item);

    document.getElementById('status-text').innerText = `å·²è®°å½•ï¼š${data.name} ${statusStr}`;

    // Click to open reading
    item.addEventListener('click', () => openReading(recordIndex));

    // Auto open reading after confirm
    openReading(recordIndex);
    
    // Mark pending next but DON'T remove card yet
    pendingNextCard = true; 
}

function closeReading() {
    const panel = document.getElementById('reading-panel');
    panel.classList.add('hidden');

    // å¦‚æœæœ‰å¾…å¤„ç†çš„å¡ç‰Œï¼ˆåˆšåˆšæŠ½å®Œçš„ï¼‰
    if (pendingNextCard && cardMesh) {
        // è§¦å‘ç°çƒ¬æ•ˆæœ
        createAshEffect(cardMesh.position);
        
        scene.remove(cardMesh);
        cardMesh.geometry.dispose();
        cardMesh.material.forEach(m => m.dispose());
        cardMesh = null;
        // 1.5ç§’åé‡æ–°ç”Ÿæˆ 3D ç¯ç»•ç‰Œé˜µï¼Œå›åˆ°é€‰æ‹©ç•Œé¢
        setTimeout(() => spawnDeckIntro(), 1500); 
        pendingNextCard = false;
    }
}

function animate() {
    requestAnimationFrame(animate);

    const time = Date.now() * 0.001;
    
    // Update Shader Time
    if (cardMesh) {
        if (cardMesh.userData?.shaderMats?.length) {
            cardMesh.userData.shaderMats.forEach(m => { if (m?.uniforms?.time) m.uniforms.time.value = time; });
        } else if (cardMesh.material && cardMesh.material[4]?.uniforms?.time) {
            // front face shader (fallback)
            cardMesh.material[4].uniforms.time.value = time;
        }
    }

    updateInteraction();
    updateParticles();

    // Rotate Zodiac Wheel background
    if (scene.userData.zodiacWheel) {
        scene.userData.zodiacWheel.rotation.z += 0.0005;
    }

    updateAura(time);

    renderer.render(scene, camera);
}

// Start
window.onload = () => {
    inputManager.init();
    initScene();

    // Reading panel actions
    const btnClose = document.getElementById('btn-close-reading');
    const btnCopy = document.getElementById('btn-copy-reading');
    if (btnClose) btnClose.addEventListener('click', closeReading);
    if (btnCopy) btnCopy.addEventListener('click', copyReading);
};

// Resize handler
window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});

</script>
</body>
</html>

