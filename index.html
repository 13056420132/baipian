<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>WebAR Tarot - Neo Logic</title>
    <!-- Google Fonts: Inter & JetBrains Mono -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;500;800&family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #0b0518;
            --accent-color: #9d84ff; /* é­”æ³•ç´« */
            --highlight-color: #ffd700; /* æ˜Ÿæ˜Ÿé‡‘ */
            --text-primary: #ffffff;
            --text-secondary: #ccc0ff;
            --panel-bg: rgba(25, 15, 50, 0.75);
            --card-bg: rgba(40, 25, 80, 0.9);
            --border-color: rgba(157, 132, 255, 0.4);
        }

        html, body { width: 100%; height: 100%; margin: 0; padding: 0; overflow: hidden; }
        body { background-color: var(--bg-color); font-family: 'Inter', sans-serif; user-select: none; color: var(--text-primary); }
        
        #canvas-container { 
            width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; 
            background: radial-gradient(circle at 50% 50%, #1a103c 0%, #05020a 100%); 
        }
        
        /* é­”æ³•æ˜Ÿç©ºèƒŒæ™¯å¾®ç²’ (CSS æ¨¡æ‹Ÿ) */
        #canvas-container::after {
            content: ''; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background-image: 
                radial-gradient(white, rgba(255,255,255,.2) 2px, transparent 3px),
                radial-gradient(white, rgba(255,255,255,.15) 1px, transparent 2px),
                radial-gradient(rgba(255,255,255,.4), rgba(255,255,255,.1) 2px, transparent 3px);
            background-size: 550px 550px, 350px 350px, 250px 250px;
            background-position: 0 0, 40px 60px, 130px 270px;
            opacity: 0.3;
            pointer-events: none;
        }

        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 2; pointer-events: none; }

        /* Loader */
        #loader { 
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            font-family: 'JetBrains Mono', monospace; color: var(--highlight-color);
            background: var(--panel-bg); padding: 30px 50px; 
            border: 2px solid var(--accent-color); 
            border-radius: 20px;
            backdrop-filter: blur(10px);
            box-shadow: 0 0 40px rgba(157, 132, 255, 0.2);
            pointer-events: auto; text-transform: uppercase; letter-spacing: 2px;
        }
        
        /* Controls */
        #controls { position: absolute; top: 30px; right: 30px; pointer-events: auto; display: flex; gap: 12px; }
        .btn { 
            background: var(--panel-bg);
            backdrop-filter: blur(8px);
            border: 1px solid var(--border-color); 
            color: var(--text-secondary); 
            padding: 10px 24px; 
            cursor: pointer; 
            font-family: 'Inter', sans-serif;
            font-weight: 600;
            font-size: 13px; 
            border-radius: 30px; /* åœ†è§’èƒ¶å›Š */
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            text-transform: uppercase;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }
        .btn:hover { 
            border-color: var(--highlight-color);
            color: var(--highlight-color);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(157, 132, 255, 0.3);
        }
        .btn.active { 
            background: var(--accent-color); 
            color: #fff; 
            border-color: var(--accent-color); 
            box-shadow: 0 0 20px rgba(157, 132, 255, 0.5); 
        }

        /* History Panel */
        #history-panel { 
            position: absolute; top: 30px; left: 30px; 
            width: 300px; max-height: 80vh; 
            overflow-y: hidden; 
            pointer-events: auto; 
            display: flex; flex-direction: column;
            gap: 12px;
        }

        /* Reading Panel */
        .reading-panel{
            position: absolute;
            top: 30px;
            right: 30px;
            width: 340px;
            max-height: 80vh;
            pointer-events: auto;
            background: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: 18px;
            box-shadow: 0 10px 35px rgba(0,0,0,0.45);
            backdrop-filter: blur(10px);
            overflow: hidden;
            transform: translateY(0);
            opacity: 1;
            transition: opacity 0.25s ease, transform 0.25s ease;
        }
        .reading-panel.hidden{
            opacity: 0;
            transform: translateY(10px);
            pointer-events: none;
        }
        .reading-header{
            display: flex;
            align-items: flex-start;
            justify-content: space-between;
            padding: 14px 14px 10px 14px;
            border-bottom: 1px solid rgba(157, 132, 255, 0.18);
            background: linear-gradient(180deg, rgba(157,132,255,0.12), transparent);
        }
        .reading-title #reading-name{
            font-weight: 800;
            color: var(--highlight-color);
            letter-spacing: 0.4px;
            font-size: 15px;
            text-shadow: 0 0 12px rgba(255,215,0,0.22);
        }
        .reading-orientation{
            margin-top: 4px;
            font-size: 12px;
            color: var(--text-secondary);
            opacity: 0.9;
        }
        .reading-actions{
            display: flex;
            gap: 12px;
        }
        .btn.btn-mini{
            padding: 10px 18px; /* Slightly larger for touch */
            font-size: 13px;
        }
        .reading-body{
            padding: 12px 14px 14px 14px;
            color: var(--text-secondary);
            font-size: 13px;
            line-height: 1.6;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            max-height: calc(80vh - 58px);
        }
        .reading-body h4{
            margin: 10px 0 6px 0;
            font-size: 12px;
            color: #fff;
            letter-spacing: 0.8px;
            text-transform: uppercase;
            opacity: 0.95;
        }
        .reading-body p{
            margin: 0 0 10px 0;
        }
        .reading-chip{
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 4px 10px;
            border-radius: 999px;
            border: 1px solid rgba(157,132,255,0.35);
            background: rgba(157,132,255,0.10);
            color: #fff;
            font-size: 12px;
            margin: 0 8px 10px 0;
        }

        /* AI Reading Section Styles */
        .ai-header {
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px dashed var(--border-color);
            color: var(--highlight-color);
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            letter-spacing: 1px;
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 10px;
        }
        .ai-content {
            font-size: 14px;
            line-height: 1.7;
            color: #e0d5ff;
            background: rgba(157, 132, 255, 0.05);
            padding: 15px;
            border-radius: 12px;
            border: 1px solid rgba(157, 132, 255, 0.1);
        }
        .loading-dots:after {
            content: '...';
            animation: dots 1.5s steps(5, end) infinite;
        }
        @keyframes dots {
            0%, 20% { content: ''; }
            40% { content: '.'; }
            60% { content: '..'; }
            80% { content: '...'; }
        }
        
        .history-item { 
            background: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: 16px;
            padding: 16px; 
            animation: slideIn 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
            position: relative;
            backdrop-filter: blur(5px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            transition: transform 0.2s;
            cursor: pointer;
        }
        .history-item:hover {
            transform: scale(1.02);
            border-color: var(--highlight-color);
        }

        .history-name { 
            color: var(--highlight-color); 
            font-weight: 700; font-size: 15px; 
            letter-spacing: 0.5px; margin-bottom: 6px; 
            display: flex; justify-content: space-between;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.3);
        }
        .history-meaning { color: var(--text-secondary); font-size: 13px; line-height: 1.5; font-weight: 300; }
        .reversed-tag { 
            color: #ff6b6b; 
            background: rgba(255, 107, 107, 0.1);
            font-size: 10px; 
            border: 1px solid #ff6b6b; 
            padding: 2px 6px; 
            border-radius: 4px; 
            margin-left: 8px; 
            vertical-align: middle;
        }

        /* Status & Charge */
        #status-container {
            position: absolute; bottom: 50px; width: 100%; 
            display: flex; flex-direction: column; align-items: center; 
            pointer-events: none;
        }
        #status-text { 
            color: #fff; 
            font-family: 'Inter', sans-serif; 
            font-weight: 500;
            font-size: 15px; 
            letter-spacing: 1px;
            background: rgba(40, 25, 80, 0.85);
            padding: 12px 30px;
            border-radius: 50px;
            border: 1px solid var(--accent-color);
            backdrop-filter: blur(8px);
            box-shadow: 0 0 20px rgba(157, 132, 255, 0.3);
        }
        
        #charge-bar-container {
            width: 240px; height: 4px; 
            background: rgba(255,255,255,0.1); 
            border-radius: 2px;
            margin-top: 15px; overflow: hidden;
            position: relative;
        }
        #charge-bar {
            width: 0%; height: 100%; 
            background: var(--highlight-color); 
            box-shadow: 0 0 15px var(--highlight-color);
            transition: width 0.05s linear;
            border-radius: 2px;
        }

        /* Mobile Optimization */
        @media (max-width: 768px) {
            #history-panel { 
                top: auto; bottom: 0; left: 0; 
                width: 100%; height: 160px; 
                max-height: 25vh; 
                flex-direction: row; 
                overflow-x: auto; 
                overflow-y: hidden;
                background: linear-gradient(to top, rgba(11, 5, 24, 0.95), transparent); 
                padding: 15px; 
                box-sizing: border-box; 
                gap: 15px;
                scrollbar-width: none; /* Hide scrollbar Firefox */
            }
            #history-panel::-webkit-scrollbar { display: none; } /* Hide scrollbar Chrome/Safari */

            .history-item { 
                flex: 0 0 140px; /* Horizontal scroll items */
                height: 110px;
                margin-bottom: 0; 
                border-radius: 12px; 
                padding: 10px; 
                font-size: 11px;
                display: flex;
                flex-direction: column;
                justify-content: center;
            }
            .history-name { font-size: 13px; margin-bottom: 4px; }
            .history-meaning { 
                display: -webkit-box;
                -webkit-line-clamp: 3;
                -webkit-box-orient: vertical;
                overflow: hidden;
                font-size: 11px;
            }

            #controls { top: 10px; right: 10px; gap: 8px; }
            .btn { padding: 8px 16px; font-size: 12px; }

            #status-container { bottom: 180px; } 
            #status-text { font-size: 13px; padding: 10px 20px; }

            .reading-panel {
                left: 0; right: 0; top: auto; bottom: 0;
                width: 100%; height: 75vh;
                max-height: 75vh;
                border-radius: 24px 24px 0 0;
                transform: translateY(100%);
                z-index: 1000;
            }
            .reading-panel.hidden {
                transform: translateY(100%);
                opacity: 1; /* Keep visible for transition */
            }
            .reading-panel:not(.hidden) {
                transform: translateY(0);
            }
            .reading-body {
                max-height: calc(75vh - 70px);
                padding-bottom: 40px;
            }
            .ai-content { font-size: 13px; padding: 12px; }
        }
        
        /* Hand Pointer */
        #hand-pointer {
            position: absolute;
            width: 24px;
            height: 24px;
            background: var(--highlight-color);
            border-radius: 50%;
            pointer-events: none;
            z-index: 10000;
            display: none;
            box-shadow: 0 0 15px var(--highlight-color), 0 0 30px var(--accent-color);
            transition: transform 0.1s ease-out;
            border: 2px solid white;
        }
        #hand-pointer.active {
            transform: scale(1.5);
            background: #fff;
        }
        #hand-pointer.pinch {
            background: #00ff00;
            box-shadow: 0 0 20px #00ff00;
        }
        #hand-pointer.fist {
            background: #ff0000;
            box-shadow: 0 0 20px #ff0000;
        }
        @keyframes slideIn { from { opacity: 0; transform: translateY(20px) scale(0.9); } to { opacity: 1; transform: translateY(0) scale(1); } }
    </style>
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- MediaPipe Hands -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="canvas-container"></div>
    <video class="input_video"></video>
    <div id="hand-pointer"></div>

    <div id="ui-layer">
        <div id="loader">
            <div>åˆå§‹åŒ–ç¥ç§˜é¢†åŸŸ...</div>
            <div id="loading-details" style="font-size: 14px; margin-top: 10px; color: #888;">åŠ è½½èµ„æºä¸­</div>
        </div>

        <div id="controls">
            <button class="btn" id="btn-mouse" onclick="inputManager.setMode('mouse')">ğŸ–±ï¸ é¼ æ ‡æ¨¡å¼</button>
            <button class="btn active" id="btn-hand" onclick="inputManager.setMode('hand')">âœ‹ æ‰‹åŠ¿æ¨¡å¼</button>
        </div>

        <div id="history-panel">
            <!-- History items will be injected here -->
        </div>

        <!-- Reading Panel -->
        <div id="reading-panel" class="reading-panel hidden">
            <div class="reading-header">
                <div class="reading-title">
                    <div id="reading-name">å¡”ç½—è§£è¯»</div>
                    <div id="reading-orientation" class="reading-orientation">â€”</div>
                </div>
                <div class="reading-actions">
                    <button class="btn btn-mini" id="btn-copy-reading">å¤åˆ¶</button>
                    <button class="btn btn-mini" id="btn-close-reading">å…³é—­</button>
                </div>
            </div>
            <div id="reading-body" class="reading-body"></div>
        </div>

        <div id="status-container">
            <div id="status-text">åˆå§‹åŒ–ä¸­...</div>
            <div id="charge-bar-container">
                <div id="charge-bar"></div>
            </div>
        </div>
    </div>

<script>
/**
 * å¡”ç½—ç‰Œæ•°æ® (Rider-Waite-Smith ç®€æ˜“åº“)
 * å›¾ç‰‡æ¥æºï¼šGithub é•œåƒ
 */
const TAROT_DATA = [
    { id: 'fool', name: 'The Fool (æ„šè€…)', url: 'https://upload.wikimedia.org/wikipedia/commons/9/90/RWS_Tarot_00_Fool.jpg', upright: 'æ–°çš„å¼€å§‹ã€å†’é™©ã€çº¯çœŸ', reversed: 'é²è½ã€å†’é™©å¸¦æ¥çš„é£é™©' },
    { id: 'magician', name: 'The Magician (é­”æœ¯å¸ˆ)', url: 'https://upload.wikimedia.org/wikipedia/commons/d/de/RWS_Tarot_01_Magician.jpg', upright: 'æ„å¿—åŠ›ã€åˆ›é€ ã€æ˜¾åŒ–', reversed: 'æ¬ºéª—ã€ç¼ºä¹åˆ›é€ åŠ›' },
    { id: 'priestess', name: 'High Priestess (å¥³ç¥­å¸)', url: 'https://upload.wikimedia.org/wikipedia/commons/8/88/RWS_Tarot_02_High_Priestess.jpg', upright: 'ç›´è§‰ã€æ½œæ„è¯†ã€ç¥ç§˜', reversed: 'å‹æŠ‘ç›´è§‰ã€è‚¤æµ…' },
    { id: 'empress', name: 'The Empress (çš‡å)', url: 'https://upload.wikimedia.org/wikipedia/commons/d/d2/RWS_Tarot_03_Empress.jpg', upright: 'ä¸°é¥¶ã€æ¯æ€§ã€è‡ªç„¶', reversed: 'ä¾èµ–ã€åˆ›é€ åŠ›å—é˜»' },
    { id: 'emperor', name: 'The Emperor (çš‡å¸)', url: 'https://upload.wikimedia.org/wikipedia/commons/c/c3/RWS_Tarot_04_Emperor.jpg', upright: 'æƒå¨ã€ç»“æ„ã€çˆ¶æ€§', reversed: 'æš´æ”¿ã€ç¼ºä¹çºªå¾‹' },
    { id: 'hierophant', name: 'The Hierophant (æ•™çš‡)', url: 'https://upload.wikimedia.org/wikipedia/commons/8/8d/RWS_Tarot_05_Hierophant.jpg', upright: 'ä¼ ç»Ÿã€ç²¾ç¥æŒ‡å¼•', reversed: 'åå›ã€æ–°çš„ä¿¡ä»°' },
    { id: 'lovers', name: 'The Lovers (æ‹äºº)', url: 'https://upload.wikimedia.org/wikipedia/commons/3/3a/RWS_Tarot_06_Lovers.jpg', upright: 'çˆ±ã€å’Œè°ã€é€‰æ‹©', reversed: 'ä¸å¹³è¡¡ã€åˆ†ç¦»' },
    { id: 'chariot', name: 'The Chariot (æˆ˜è½¦)', url: 'https://upload.wikimedia.org/wikipedia/commons/9/9b/RWS_Tarot_07_Chariot.jpg', upright: 'æ§åˆ¶ã€æ„å¿—åŠ›ã€èƒœåˆ©', reversed: 'å¤±æ§ã€ä¾µç•¥' },
    { id: 'strength', name: 'Strength (åŠ›é‡)', url: 'https://upload.wikimedia.org/wikipedia/commons/f/f5/RWS_Tarot_08_Strength.jpg', upright: 'å‹‡æ°”ã€è€å¿ƒã€åŒæƒ…', reversed: 'è½¯å¼±ã€è‡ªæˆ‘æ€€ç–‘' },
    { id: 'hermit', name: 'The Hermit (éšå£«)', url: 'https://upload.wikimedia.org/wikipedia/commons/4/4d/RWS_Tarot_09_Hermit.jpg', upright: 'å†…çœã€å¯»æ‰¾çœŸç†', reversed: 'å­¤ç‹¬ã€å­¤ç«‹' },
    { id: 'wheel', name: 'Wheel of Fortune (å‘½è¿ä¹‹è½®)', url: 'https://upload.wikimedia.org/wikipedia/commons/3/3c/RWS_Tarot_10_Wheel_of_Fortune.jpg', upright: 'å¥½è¿ã€ä¸šåŠ›ã€è½¬æŠ˜ç‚¹', reversed: 'å„è¿ã€æŠµæŠ—å˜åŒ–' },
    { id: 'justice', name: 'Justice (æ­£ä¹‰)', url: 'https://upload.wikimedia.org/wikipedia/commons/e/e0/RWS_Tarot_11_Justice.jpg', upright: 'å…¬æ­£ã€çœŸç†ã€å› æœ', reversed: 'ä¸å…¬ã€é€ƒé¿è´£ä»»' },
    { id: 'hanged_man', name: 'The Hanged Man (å€’åŠäºº)', url: 'https://upload.wikimedia.org/wikipedia/commons/2/2b/RWS_Tarot_12_Hanged_Man.jpg', upright: 'ç‰ºç‰²ã€æ–°è§†è§’ã€ç­‰å¾…', reversed: 'æ— è°“çš„ç‰ºç‰²ã€åœæ»' },
    { id: 'death', name: 'Death (æ­»ç¥)', url: 'https://upload.wikimedia.org/wikipedia/commons/d/d7/RWS_Tarot_13_Death.jpg', upright: 'ç»“æŸã€è½¬å˜ã€é‡ç”Ÿ', reversed: 'æŠ—æ‹’æ”¹å˜ã€åœæ»' },
    { id: 'temperance', name: 'Temperance (èŠ‚åˆ¶)', url: 'https://upload.wikimedia.org/wikipedia/commons/f/f8/RWS_Tarot_14_Temperance.jpg', upright: 'å¹³è¡¡ã€é€‚åº¦ã€è€å¿ƒ', reversed: 'ä¸å¹³è¡¡ã€è¿‡åº¦' },
    { id: 'devil', name: 'The Devil (æ¶é­”)', url: 'https://upload.wikimedia.org/wikipedia/commons/5/55/RWS_Tarot_15_Devil.jpg', upright: 'æŸç¼šã€ç‰©è´¨ä¸»ä¹‰', reversed: 'æ‰“ç ´æŸç¼šã€é‡è·è‡ªç”±' },
    { id: 'tower', name: 'The Tower (å¡”)', url: 'https://upload.wikimedia.org/wikipedia/commons/5/53/RWS_Tarot_16_Tower.jpg', upright: 'çªå˜ã€æ··ä¹±ã€å¯ç¤º', reversed: 'é¿å…ç¾éš¾ã€å»¶è¿Ÿæ”¹å˜' },
    { id: 'star', name: 'The Star (æ˜Ÿæ˜Ÿ)', url: 'https://upload.wikimedia.org/wikipedia/commons/d/db/RWS_Tarot_17_Star.jpg', upright: 'å¸Œæœ›ã€çµæ„Ÿã€å®é™', reversed: 'ç»æœ›ã€ç¼ºä¹ä¿¡å¿ƒ' },
    { id: 'moon', name: 'The Moon (æœˆäº®)', url: 'https://upload.wikimedia.org/wikipedia/commons/7/7f/RWS_Tarot_18_Moon.jpg', upright: 'å¹»è§‰ã€ææƒ§ã€æ½œæ„è¯†', reversed: 'é‡Šæ”¾ææƒ§ã€æ¸…æ™°' },
    { id: 'sun', name: 'The Sun (å¤ªé˜³)', url: 'https://upload.wikimedia.org/wikipedia/commons/1/17/RWS_Tarot_19_Sun.jpg', upright: 'å¿«ä¹ã€æˆåŠŸã€æ´»åŠ›', reversed: 'æš‚æ—¶çš„æ¶ˆæ²‰' },
    { id: 'judgement', name: 'Judgement (å®¡åˆ¤)', url: 'https://upload.wikimedia.org/wikipedia/commons/d/dd/RWS_Tarot_20_Judgement.jpg', upright: 'è§‰é†’ã€é‡ç”Ÿã€å†³å®š', reversed: 'è‡ªæˆ‘æ€€ç–‘ã€æ‹’ç»å¬å”¤' },
    { id: 'world', name: 'The World (ä¸–ç•Œ)', url: 'https://upload.wikimedia.org/wikipedia/commons/f/ff/RWS_Tarot_21_World.jpg', upright: 'å®Œæˆã€æ•´åˆã€æ—…è¡Œ', reversed: 'æœªå®Œæˆã€ç¼ºä¹é—­ç¯' }
];

// é­”æ³•é£æ ¼å¡èƒŒçº¹ç† (å‚è€ƒå›¾ç‰‡é£æ ¼ - çŸ¢é‡æ‰å¹³)
function createMagicalBackTexture() {
    const canvas = document.createElement('canvas');
    canvas.width = 512;
    canvas.height = 896;
    const ctx = canvas.getContext('2d');
    const w = canvas.width;
    const h = canvas.height;

    // 1. èƒŒæ™¯ï¼šé­”æ³•æ·±ç´«æ¸å˜
    const grad = ctx.createLinearGradient(0, 0, 0, h);
    grad.addColorStop(0, '#35225e'); // äº®ç´«
    grad.addColorStop(0.5, '#1a103c'); // æ·±è“ç´«
    grad.addColorStop(1, '#35225e');
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, w, h);

    // 2. è£…é¥°å›¾æ¡ˆ
    ctx.translate(w/2, h/2);
    
    // èƒŒæ™¯å‡ ä½•çº¿æ¡
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(0, 0, 180, 0, Math.PI*2);
    ctx.stroke();
    
    // æ—‹è½¬æ­£æ–¹å½¢æ¡†
    ctx.strokeStyle = 'rgba(176, 160, 255, 0.3)';
    ctx.strokeRect(-140, -140, 280, 280);
    ctx.save();
    ctx.rotate(Math.PI/4);
    ctx.strokeRect(-140, -140, 280, 280);
    ctx.restore();

    // 3. æ ¸å¿ƒå›¾æ¡ˆï¼šå¤ªé˜³/æ˜Ÿæ˜Ÿ (å¼ºå‘å…‰)
    ctx.shadowBlur = 40;
    ctx.shadowColor = '#e0c0ff'; // ç´«ç™½å…‰æ™•
    
    // ä¸»ä½“å…«è§’æ˜Ÿ
    ctx.fillStyle = '#ffffff';
    ctx.beginPath();
    for(let i=0; i<16; i++) {
        const r = i%2===0 ? 110 : 40; // é•¿çŸ­å…‰èŠ’
        const angle = i * Math.PI / 8;
        const x = Math.cos(angle) * r;
        const y = Math.sin(angle) * r;
        if(i===0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
    }
    ctx.closePath();
    ctx.fill();
    
    // å†…éƒ¨é•‚ç©ºåœ†
    ctx.shadowBlur = 0;
    ctx.fillStyle = '#1a103c'; 
    ctx.beginPath();
    ctx.arc(0, 0, 25, 0, Math.PI*2);
    ctx.fill();
    
    // å†…éƒ¨å°æ˜Ÿ
    ctx.fillStyle = '#b0a0ff';
    ctx.beginPath();
    for(let i=0; i<8; i++) {
        const r = i%2===0 ? 20 : 10;
        const angle = i * Math.PI / 4;
        const x = Math.cos(angle) * r;
        const y = Math.sin(angle) * r;
        if(i===0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
    }
    ctx.fill();

    // 4. è¾¹æ¡†
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.shadowBlur = 10;
    ctx.shadowColor = '#b0a0ff';
    ctx.strokeStyle = '#b0a0ff';
    ctx.lineWidth = 8;
    ctx.strokeRect(20, 20, w-40, h-40);
    
    // è§’è½èŠ±çº¹è£…é¥°
    const drawCorner = (x, y) => {
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(x-5, y-5, 10, 10);
    };
    drawCorner(20, 20);
    drawCorner(w-20, 20);
    drawCorner(20, h-20);
    drawCorner(w-20, h-20);

    const tex = new THREE.CanvasTexture(canvas);
    tex.anisotropy = renderer.capabilities.getMaxAnisotropy();
    return tex;
}

// ================= é­”æ³•å¡é¢ç€è‰²å™¨ (Magic Shader) =================
// å°†æ™®é€šå›¾ç‰‡å®æ—¶è½¬æ¢ä¸ºâ€œç´«é‡‘æµå…‰â€é£æ ¼
const MagicCardShader = {
    vertexShader: `
        varying vec2 vUv;
        varying vec3 vPosition;
        void main() {
            vUv = uv;
            vPosition = position;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    fragmentShader: `
        uniform sampler2D map;
        uniform vec3 colorDark;
        uniform vec3 colorLight;
        uniform vec3 colorAccent;
        uniform float time;
        varying vec2 vUv;
        varying vec3 vPosition;

        void main() {
            // 1. é‡‡æ ·åŸå›¾ (ç§»é™¤ç™½è¾¹: ç¨å¾®ç¼©æ”¾ UV)
            vec2 uv = (vUv - 0.5) * 0.92 + 0.5; 
            vec4 tex = texture2D(map, uv);
            
            // 2. è®¡ç®—äº®åº¦ (Luminance)
            float gray = dot(tex.rgb, vec3(0.299, 0.587, 0.114));
            
            // 3. å¢åŠ å¯¹æ¯”åº¦ï¼Œä½¿å›¾æ¡ˆæ›´æ¸…æ™°
            float contrast = smoothstep(0.2, 0.7, gray);
            
            // 4. ç´«é‡‘åŒè‰²è°ƒæ˜ å°„ (Duotone Mapping)
            // æš—éƒ¨ -> æ·±ç´«, äº®éƒ¨ -> é‡‘è‰²
            vec3 finalColor = mix(colorDark, colorLight, contrast);
            
            // 5. åŠ¨æ€æµå…‰æ•ˆæœ (Shimmer)
            // åŸºäºä½ç½®å’Œæ—¶é—´çš„æ–œå‘å…‰æ³¢
            float shimmer = sin(vUv.y * 10.0 + vUv.x * 10.0 - time * 2.0) * 0.5 + 0.5;
            // ä»…åœ¨äº®éƒ¨(é‡‘è‰²åŒºåŸŸ)åº”ç”¨æµå…‰
            finalColor += colorAccent * shimmer * contrast * 0.3;

            // 6. è¾¹ç¼˜æš—è§’ (Vignette)
            float dist = distance(vUv, vec2(0.5));
            finalColor *= smoothstep(0.8, 0.3, dist);

            gl_FragColor = vec4(finalColor, 1.0);
        }
    `
};

// ================= å…¨å±€å˜é‡ =================
let scene, camera, renderer;
let cardMesh = null;
let introCards = []; // Store intro deck meshes
let particles = [];
let deck = [...TAROT_DATA];
let isProcessingEffect = false;
let globalMaterials = null; // Store generated materials

// History data store (for reading replay)
let historyRecords = [];
let pendingNextCard = false;



// äº¤äº’çŠ¶æ€
const INTERACTION = {
    mode: 'hand', // 'hand' | 'mouse'
    state: 'INTRO', // 'INTRO', 'IDLE', 'HOVER', 'GRABBED', 'LOCKED'
    raycaster: new THREE.Raycaster(),
    pointer: new THREE.Vector2(), 
    gesture: 'NONE', 
    handPosition: new THREE.Vector3(),
    pinchDistance: 0,
    fistStartTime: 0 
};

// ================= è¾“å…¥ç®¡ç†å™¨ (MediaPipe + Mouse) =================
const inputManager = {
    videoElement: document.querySelector('.input_video'),
    hands: null,
    camera: null,

    init: async function() {
        console.log("æ­£åœ¨åˆå§‹åŒ–æ‰‹åŠ¿è¯†åˆ«ç³»ç»Ÿ...");
        document.getElementById('status-text').innerText = "æ­£åœ¨å¯åŠ¨æ˜Ÿç•Œæ„Ÿåº”ç³»ç»Ÿ...";
        
        // MediaPipe Setup
        try {
            this.hands = new Hands({locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }});
        } catch (err) {
            console.error("MediaPipe åº“åŠ è½½å¤±è´¥:", err);
            document.getElementById('status-text').innerText = "åº“æ–‡ä»¶åŠ è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œ";
            return;
        }
        
        this.hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 0, // é™ä½æ¨¡å‹å¤æ‚åº¦ä»¥æé«˜é€Ÿåº¦ (0=Lite, 1=Full)
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        this.hands.onResults(this.onHandsResults.bind(this));

        // å°è¯•å¯åŠ¨æ‘„åƒå¤´
        try {
            let lastVideoTime = 0;
            const fpsInterval = 1000 / 20; // é™åˆ¶æ‰‹åŠ¿è¯†åˆ«ä¸º 20 FPS

            this.camera = new Camera(this.videoElement, {
                onFrame: async () => {
                    const now = Date.now();
                    if (now - lastVideoTime < fpsInterval) return;
                    lastVideoTime = now;
                    await this.hands.send({image: this.videoElement});
                },
                width: 320, // é™ä½å¤„ç†åˆ†è¾¨ç‡æé«˜æ€§èƒ½
                height: 240
            });
            await this.camera.start();
            this.setMode('hand');
        } catch (e) {
            console.warn("Camera failed, fallback to mouse", e);
            document.getElementById('status-text').innerText = "æ‘„åƒå¤´ä¸å¯ç”¨ï¼Œå·²åˆ‡æ¢è‡³é¼ æ ‡æ¨¡å¼";
            this.setMode('mouse');
        }

        // Mouse Listeners
        const updatePointer = (clientX, clientY) => {
            INTERACTION.pointer.x = (clientX / window.innerWidth) * 2 - 1;
            INTERACTION.pointer.y = -(clientY / window.innerHeight) * 2 + 1;
        };

        window.addEventListener('mousemove', (e) => {
            if (INTERACTION.mode === 'mouse') {
                updatePointer(e.clientX, e.clientY);
                if (INTERACTION.state === 'IDLE' || INTERACTION.state === 'HOVER') {
                    INTERACTION.gesture = 'OPEN';
                }
            }
        });

        window.addEventListener('mousedown', (e) => {
            if (INTERACTION.mode === 'mouse' && !isProcessingEffect) {
                if (e.button === 0) INTERACTION.gesture = 'PINCH';
            }
        });

        window.addEventListener('mouseup', (e) => {
            if (INTERACTION.mode === 'mouse' && !isProcessingEffect) {
                if (INTERACTION.state === 'GRABBED') INTERACTION.gesture = 'OPEN';
            }
        });
        
        // Touch Support for Mobile
        window.addEventListener('touchmove', (e) => {
            if (INTERACTION.mode === 'mouse' && e.touches.length > 0) {
                e.preventDefault();
                updatePointer(e.touches[0].clientX, e.touches[0].clientY);
            }
        }, {passive: false});

        window.addEventListener('touchstart', (e) => {
            if (INTERACTION.mode === 'mouse' && e.touches.length > 0) {
                updatePointer(e.touches[0].clientX, e.touches[0].clientY);
                INTERACTION.gesture = 'PINCH';
            }
        }, {passive: false});

        window.addEventListener('touchend', () => {
            if (INTERACTION.mode === 'mouse') {
                if (INTERACTION.state === 'GRABBED') INTERACTION.gesture = 'OPEN';
                // æ¨¡æ‹ŸåŒå‡»æˆ–é•¿æŒ‰å¯èƒ½æ¯”è¾ƒå¤æ‚ï¼Œè¿™é‡Œç®€åŒ–ä¸ºæ¾å¼€å³æ”¾å¼€
            }
        });

        window.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            if (INTERACTION.mode === 'mouse' && INTERACTION.state === 'GRABBED') {
                INTERACTION.gesture = 'FIST'; // Right click confirms
            }
        });
    },

    setMode: function(mode) {
        INTERACTION.mode = mode;
        document.getElementById('btn-mouse').className = mode === 'mouse' ? 'btn active' : 'btn';
        document.getElementById('btn-hand').className = mode === 'hand' ? 'btn active' : 'btn';
        
        const status = document.getElementById('status-text');
        if (mode === 'mouse') {
            status.innerText = "é¼ æ ‡æ¨¡å¼: å·¦é”®æ‹–æ‹½å¡ç‰Œï¼Œå³é”®ç¡®è®¤æŠ½å–";
            // Stop camera to save resources if explicitly switched
            if (this.videoElement.srcObject) {
               // this.videoElement.srcObject.getTracks().forEach(track => track.stop());
            }
        } else {
            status.innerText = "æ‰‹åŠ¿æ¨¡å¼: å¼ å¼€=ç§»åŠ¨ | æåˆ=æŠ“å– | æ¡æ‹³=ç¡®è®¤";
            // å¦‚æœæ‰‹åŠ¿åˆå§‹åŒ–è¿˜æ²¡å®Œæˆï¼Œæç¤ºä¸€ä¸‹
            if (!this.camera) {
                status.innerText = "æ­£åœ¨å¯åŠ¨æ‘„åƒå¤´...";
            }
        }
    },

    onHandsResults: function(results) {
        if (INTERACTION.mode !== 'hand') return;

        const pointerEl = document.getElementById('hand-pointer');
        
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const landmarks = results.multiHandLandmarks[0];
            
            // 1. Calculate Pointer (Index Tip)
            const indexTip = landmarks[8];
            // MediaPipe x is 0-1, y is 0-1.
            // On some mobile devices, we might need to NOT flip X if the browser already does it.
            // But usually for mirrored front camera:
            INTERACTION.pointer.x = -((indexTip.x * 2) - 1); 
            INTERACTION.pointer.y = -(indexTip.y * 2) + 1;

            // Update Visual Pointer
            pointerEl.style.display = 'block';
            pointerEl.style.left = `${indexTip.x * 100}%`;
            pointerEl.style.top = `${indexTip.y * 100}%`;
            
            // Mirror X for visual pointer if mirrored
            pointerEl.style.left = `${(1 - indexTip.x) * 100}%`;

            // 2. Gesture Recognition
            this.recognizeGesture(landmarks);
            
            // Update pointer visual state
            pointerEl.className = INTERACTION.gesture.toLowerCase();
            
        } else {
            INTERACTION.gesture = 'NONE';
            pointerEl.style.display = 'none';
        }
    },

    recognizeGesture: function(landmarks) {
        const wrist = landmarks[0];
        const thumbTip = landmarks[4];
        const indexTip = landmarks[8];
        const middleTip = landmarks[12];
        const ringTip = landmarks[16];
        const pinkyTip = landmarks[20];
        
        const indexPip = landmarks[6];
        const middlePip = landmarks[10];
        const ringPip = landmarks[14];
        const pinkyPip = landmarks[18];

        // åŸºç¡€æ‰‹æŒå¤§å°å‚è€ƒ (è…•éƒ¨åˆ°ä¸­æŒ‡æ ¹éƒ¨çš„è·ç¦»)
        const middleMcp = landmarks[9];
        const handSize = Math.hypot(wrist.x - middleMcp.x, wrist.y - middleMcp.y);

        // Normalized distance between thumb and index tip
        const pinchDist = Math.hypot(thumbTip.x - indexTip.x, thumbTip.y - indexTip.y);
        INTERACTION.pinchDistance = pinchDist;

        const isFingerExtended = (tip, pip) => {
            const dTip = Math.hypot(tip.x - wrist.x, tip.y - wrist.y);
            const dPip = Math.hypot(pip.x - wrist.x, pip.y - wrist.y);
            return dTip > dPip;
        };

        const iExt = isFingerExtended(indexTip, indexPip);
        const mExt = isFingerExtended(middleTip, middlePip);
        const rExt = isFingerExtended(ringTip, ringPip);
        const pExt = isFingerExtended(pinkyTip, pinkyPip);

        // 1. FIST: All fingers folded relative to their PIPs
        if (!iExt && !mExt && !rExt && !pExt) {
            INTERACTION.gesture = 'FIST';
            return;
        }

        // 2. PINCH: Thumb very close to index tip relative to hand size
        if (pinchDist < handSize * 0.4) {
            INTERACTION.gesture = 'PINCH';
            return;
        }

        // 3. POINT: Index extended, others folded
        if (iExt && !mExt && !rExt && !pExt) {
            INTERACTION.gesture = 'POINT';
            return;
        }

        // 4. OPEN: Default if index is extended
        if (iExt) {
            INTERACTION.gesture = 'OPEN';
            return;
        }

        INTERACTION.gesture = 'NONE';
    }
};

// ================= Three.js é€»è¾‘ =================
function initScene() {
    scene = new THREE.Scene();
    // Fog for depth
    scene.fog = new THREE.FogExp2(0x111111, 0.02);

    camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.z = 5;

    renderer = new THREE.WebGLRenderer({ antialias: window.devicePixelRatio < 2, alpha: true, powerPreference: "high-performance" });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    document.getElementById('canvas-container').appendChild(renderer.domElement);

    // Lights
    const ambientLight = new THREE.AmbientLight(0x404040, 1.5); // å¢åŠ ç¯å¢ƒå…‰ä»¥æ˜¾ç¤ºæ’ç”»é¢œè‰²
    scene.add(ambientLight);

    // Dramatic SpotLight
    const spotLight = new THREE.SpotLight(0xffffff, 1.5);
    spotLight.position.set(0, 5, 8);
    spotLight.angle = Math.PI / 3;
    spotLight.penumbra = 0.5;
    spotLight.distance = 30;
    scene.add(spotLight);

    // Dynamic point light following card
    const pointLight = new THREE.PointLight(0xb0a0ff, 0, 10); // ç´«è‰²å…‰
    scene.add(pointLight);
    scene.userData.pointLight = pointLight;

    // Generate Textures
    const magicalTex = createMagicalBackTexture();
    globalMaterials = {
        back: new THREE.MeshStandardMaterial({ 
            map: magicalTex, 
            roughness: 0.4, 
            metalness: 0.1, // éé‡‘å±
            emissive: 0x222222, // ç¨å¾®è‡ªå‘å…‰
            emissiveMap: magicalTex,
            emissiveIntensity: 0.5
        }),
        side: new THREE.MeshStandardMaterial({ 
            color: 0x35225e, 
            emissive: 0x1a103c,
        })
    };

    // Start with Intro Deck
    spawnDeckIntro();
    
    // Hide loader
    document.getElementById('loader').style.opacity = 0;
    setTimeout(() => document.getElementById('loader').style.display = 'none', 500);

    animate();
}

function spawnDeckIntro() {
    INTERACTION.state = 'INTRO';
    document.getElementById('status-text').innerText = "è¯·ä»ç‰Œé˜µä¸­æ„Ÿåº”å¹¶é€‰æ‹©ä¸€å¼ ";
    
    // Exactly 5 cards as requested
    const count = 5;
    const radius = 6; 
    const arcAngle = Math.PI * 0.4; 
    
    const geometry = new THREE.BoxGeometry(1.5, 2.6, 0.02);
    
    // Apply materials
    const materials = [
        globalMaterials.side, globalMaterials.side, 
        globalMaterials.side, globalMaterials.side, 
        globalMaterials.back, globalMaterials.back
    ];

    for (let i = 0; i < count; i++) {
        const mesh = new THREE.Mesh(geometry, materials);
        
        // Arc positioning centered
        const t = (i - (count-1)/2) / ((count-1)/2); // -1 to 1
        const angle = t * (arcAngle/2);
        
        mesh.position.x = Math.sin(angle) * radius;
        mesh.position.z = (1 - Math.cos(angle)) * radius - 1; // Curve
        
        // Face camera naturally
        mesh.rotation.y = -angle; 
        
        // Animation data
        mesh.userData = {
            introIndex: i,
            basePos: mesh.position.clone(),
            baseRot: mesh.rotation.clone(),
            targetPos: mesh.position.clone(),
            targetScale: 1.0
        };
        
        scene.add(mesh);
        introCards.push(mesh);
    }
}

function updateIntroDeck() {
    if (INTERACTION.state !== 'INTRO') return;
    
    // Raycast for general hover
    INTERACTION.raycaster.setFromCamera(INTERACTION.pointer, camera);
    const intersects = INTERACTION.raycaster.intersectObjects(introCards);
    let hoveredMesh = null;
    if (intersects.length > 0) {
        hoveredMesh = intersects[0].object;
        document.body.style.cursor = 'pointer';
        if (INTERACTION.gesture === 'PINCH') {
            selectIntroCard(hoveredMesh);
            return;
        }
    } else {
        document.body.style.cursor = 'default';
    }

    // Fish-eye / Spread Effect Logic
    // Convert pointer to world space at z=0 plane roughly
    const vec = new THREE.Vector3(INTERACTION.pointer.x, INTERACTION.pointer.y, 0.5);
    vec.unproject(camera);
    const dir = vec.sub(camera.position).normalize();
    const distance = (0 - camera.position.z) / dir.z; // Project to Z=0
    const worldMouse = camera.position.clone().add(dir.multiplyScalar(distance));

    introCards.forEach(mesh => {
        const base = mesh.userData.basePos;
        
        // Calculate distance from mouse to card's base X position
        // We focus mainly on X axis dist for the "spread" effect
        const dx = worldMouse.x - base.x;
        const dy = worldMouse.y - base.y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        
        // Effect radius
        const radius = 2.5; 
        
        if (dist < radius) {
            // Calculate influence (0 to 1)
            const influence = Math.pow(1 - dist / radius, 2); // Quadratic falloff
            
            // 1. Z-Push: Bring closer
            mesh.userData.targetPos.z = base.z + influence * 2.0; 
            
            // 2. Y-Lift: Lift up slightly
            mesh.userData.targetPos.y = base.y + influence * 0.5;
            
            // 3. Scale Up
            mesh.userData.targetScale = 1.0 + influence * 0.3;
            
            // 4. Spread X: Push away from mouse center slightly
            // If card is to the right of mouse, push right.
            // But we want "magnifying glass" feel, so actually just bringing it closer (Z) is enough?
            // Let's add slight rotation to face mouse
            mesh.userData.targetPos.x = base.x + (dx > 0 ? 1 : -1) * influence * 0.2;

        } else {
            // Reset
            mesh.userData.targetPos.copy(base);
            mesh.userData.targetScale = 1.0;
        }
        
        // Smooth Damp (Lerp)
        mesh.position.lerp(mesh.userData.targetPos, 0.1);
        mesh.scale.setScalar(THREE.MathUtils.lerp(mesh.scale.x, mesh.userData.targetScale, 0.1));
        
        // Highlighting
        if (mesh === hoveredMesh) {
            mesh.material[4].emissive.setHex(0x222222);
            mesh.material[5].emissive.setHex(0x222222);
        } else {
            mesh.material[4].emissive.setHex(0x000000);
            mesh.material[5].emissive.setHex(0x000000);
        }
    });
}

function selectIntroCard(selectedMesh) {
    if (isProcessingEffect) return;
    isProcessingEffect = true;
    
    // 1. Remove others with animation
    introCards.forEach(mesh => {
        if (mesh !== selectedMesh) {
            // Fly away effect
            const dir = mesh.position.clone().normalize();
            const animateOut = () => {
                mesh.position.add(dir.multiplyScalar(0.5));
                mesh.scale.multiplyScalar(0.9);
                if (mesh.scale.x < 0.1) {
                    scene.remove(mesh);
                } else {
                    requestAnimationFrame(animateOut);
                }
            };
            animateOut();
        }
    });
    introCards = []; // Clear array reference
    
    // 2. Transition selected mesh to be the main 'cardMesh'
    cardMesh = selectedMesh;
    
    // Generate actual data for this card now (Lazy load)
    if (deck.length === 0) return;
    const index = Math.floor(Math.random() * deck.length);
    const cardData = deck[index];
    deck.splice(index, 1);
    
    const isReversed = Math.random() < 0.5;
    
    // Load Front Texture
    const loader = new THREE.TextureLoader();
    const texFront = loader.load(cardData.url, (tex) => {
        tex.center.set(0.5, 0.5);
        
        // Use Magic Shader Material instead of Standard
        const matFront = new THREE.ShaderMaterial({
            uniforms: {
                map: { value: tex },
                colorDark: { value: new THREE.Color('#1a103c') }, // æ·±ç´«èƒŒæ™¯
                colorLight: { value: new THREE.Color('#ffd700') }, // é‡‘è‰²çº¿æ¡
                colorAccent: { value: new THREE.Color('#fff0a0') }, // é«˜å…‰
                time: { value: 0 }
            },
            vertexShader: MagicCardShader.vertexShader,
            fragmentShader: MagicCardShader.fragmentShader
        });
        
        // Save reference to animate time
        if(!cardMesh.userData.shaderMats) cardMesh.userData.shaderMats = [];
        cardMesh.userData.shaderMats.push(matFront);

        cardMesh.material = [
            cardMesh.material[0], cardMesh.material[1], 
            cardMesh.material[2], cardMesh.material[3], 
            matFront, 
            cardMesh.material[5]
        ];
    });

    // Store Game Data
    cardMesh.userData = {
        data: cardData,
        isReversed: isReversed,
        velocity: new THREE.Vector3(),
    };
    
    // Animate to Center
    const startPos = cardMesh.position.clone();
    const startRot = cardMesh.rotation.clone();
    const startTime = Date.now();
    
    const animateToCenter = () => {
        const now = Date.now();
        const progress = Math.min((now - startTime) / 1000, 1);
        const ease = 1 - Math.pow(1 - progress, 3); // Cubic out
        
        cardMesh.position.lerpVectors(startPos, new THREE.Vector3(0, 0, 0), ease);
        // Rotate to standard upright back-facing first
        // Intro cards are roughly facing Z- but rotated.
        // We want final state: IDLE (floating, back visible -> rot Y = PI)
        
        // Quaternions would be better but let's use Euler lerp for simplicity here
        cardMesh.rotation.x = THREE.MathUtils.lerp(startRot.x, 0, ease);
        cardMesh.rotation.y = THREE.MathUtils.lerp(startRot.y, Math.PI, ease); // Face back
        cardMesh.rotation.z = THREE.MathUtils.lerp(startRot.z, 0, ease);
        
        // Scale up to normal size
        cardMesh.scale.setScalar(1 + (2/1.5 - 1) * ease); // 1.5 -> 2.0 width
        
        if (progress < 1) {
            requestAnimationFrame(animateToCenter);
        } else {
            // Done
            INTERACTION.state = 'IDLE';
            isProcessingEffect = false;
            document.getElementById('status-text').innerText = "å·²æ„Ÿåº”ã€‚ç‚¹å‡»/æåˆæŠ“å–æŸ¥çœ‹";
        }
    };
    animateToCenter();
}

function spawnCard() {
    if (deck.length === 0) {
        document.getElementById('status-text').innerText = "ç‰Œåº“å·²ç©ºï¼Œå‘½è¿å·²å®šã€‚";
        return;
    }
    // ... Old spawn logic mostly replaced by Intro for first run, 
    // but useful for subsequent draws.
    // Let's keep it for "Next Card" logic.
    
    // Random selection
    const index = Math.floor(Math.random() * deck.length);
    const cardData = deck[index];
    deck.splice(index, 1); // Remove from deck

    // Orientation logic
    const isReversed = Math.random() < 0.5;
    
    // Geometry
    const geometry = new THREE.BoxGeometry(2, 3.5, 0.02);
    
    // Materials
    const loader = new THREE.TextureLoader();
    const matSide = globalMaterials?.side || new THREE.MeshStandardMaterial({ color: 0x35225e, emissive: 0x1a103c });
    
    // Front Texture (Face) - Magic Shader
    const texFront = loader.load(cardData.url);
    texFront.center.set(0.5, 0.5); 
    
    const matFront = new THREE.ShaderMaterial({
        uniforms: {
            map: { value: texFront },
            colorDark: { value: new THREE.Color('#1a103c') },
            colorLight: { value: new THREE.Color('#ffd700') },
            colorAccent: { value: new THREE.Color('#fff0a0') },
            time: { value: 0 }
        },
        vertexShader: MagicCardShader.vertexShader,
        fragmentShader: MagicCardShader.fragmentShader
    });

    // Back Texture
    const matBack = globalMaterials?.back || new THREE.MeshStandardMaterial({ color: 0x35225e });

    const materials = [matSide, matSide, matSide, matSide, matFront, matBack];

    const mesh = new THREE.Mesh(geometry, materials);
    
    // Initial Position (Bottom up spawn for subsequent cards)
    mesh.position.set(0, -5, 0); 
    mesh.rotation.y = Math.PI; 
    
    // Store data
    mesh.userData = {
        data: cardData,
        isReversed: isReversed
    };

    scene.add(mesh);
    cardMesh = mesh;

    // Reset interaction
    INTERACTION.state = 'IDLE';
    isProcessingEffect = false;
}

// ================= ç²’å­ç°çƒ¬æ•ˆæœ =================
function createAshEffect(position, color) {
    const particleCount = 2000;
    const geometry = new THREE.BufferGeometry();
    const positions = [];
    const velocities = [];
    const opacities = [];
    const sizes = [];

    // Create particles within the card's bounding box
    for (let i = 0; i < particleCount; i++) {
        // Random pos within roughly card size (2 x 3.5)
        const px = position.x + (Math.random() - 0.5) * 2;
        const py = position.y + (Math.random() - 0.5) * 3.5;
        const pz = position.z + (Math.random() - 0.5) * 0.1;
        positions.push(px, py, pz);

        // Velocity: drift up + turbulence
        velocities.push(
            (Math.random() - 0.5) * 0.05, // x
            Math.random() * 0.05 + 0.02,  // y (up)
            (Math.random() - 0.5) * 0.05  // z
        );

        opacities.push(1.0);
        sizes.push(Math.random() * 0.1 + 0.02);
    }

    geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
    geometry.setAttribute('velocity', new THREE.Float32BufferAttribute(velocities, 3));
    geometry.setAttribute('opacity', new THREE.Float32BufferAttribute(opacities, 1));
    geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));

    // Shader Material for custom fading
    const material = new THREE.PointsMaterial({
        color: 0x00f3ff,
        size: 0.1,
        transparent: true,
        opacity: 0.8,
        blending: THREE.AdditiveBlending,
        depthWrite: false
    });

    const particleSystem = new THREE.Points(geometry, material);
    particleSystem.userData = { life: 100 }; // frames
    scene.add(particleSystem);
    particles.push(particleSystem);
}

// ================= è§£è¯»ï¼ˆReadingï¼‰ =================
const API_CONFIG = {
    // 1. é…ç½®ä½ çš„ API Key (å›½å†…ä¸­è½¬ã€DeepSeekã€GPTç­‰)
    key: "sk-otrhhbpeovbxunzrjvvdxmjpjeeykhpkjfqbinlxnrvkwjbz", 
    // 2. é…ç½®æ¥å£åœ°å€ (ä¾‹å¦‚ https://api.deepseek.com/v1/chat/completions)
    endpoint: "https://api.siliconflow.cn/v1/chat/completions", 
    // 3. æ¨¡å‹åç§° (ä¾‹å¦‚ deepseek-chat, gpt-3.5-turbo ç­‰)
    modelName: "deepseek-ai/DeepSeek-V3",
    // 4. æ¥å£æ ¼å¼ï¼štrue ä½¿ç”¨ OpenAI æ ¼å¼ (DeepSeek/GPT), false ä½¿ç”¨ Gemini æ ¼å¼
    isOpenAI: true 
};

async function fetchAIInterpretation(record) {
    const { name, isReversed, meaning } = record;
    const bodyEl = document.getElementById('reading-body');
    const orientation = isReversed ? "é€†ä½" : "æ­£ä½";
    
    // Add loading indicator
    const aiSectionId = `ai-reading-${record.ts}`;
    const aiSection = document.createElement('div');
    aiSection.id = aiSectionId;
    aiSection.innerHTML = `
        <div class="ai-header">âœ¨ AI ORACLE DECODING <span class="loading-dots"></span></div>
        <div class="ai-content" style="opacity: 0.6; font-style: italic;">æ­£åœ¨è½¬è¯‘æ˜Ÿç•Œä¿¡å·...</div>
    `;
    bodyEl.appendChild(aiSection);

    const prompt = `ä½œä¸ºå¡”ç½—å åœå¸ˆï¼Œè¯·è§£è¯»è¿™å¼ ç‰Œï¼š${name}ï¼ˆ${orientation}ï¼‰ã€‚
å®ƒçš„æ ¸å¿ƒå«ä¹‰æ˜¯ï¼š${meaning}ã€‚
è¯·ç»“åˆæ­¤å«ä¹‰ï¼Œç»™æˆ‘ä¸€æ®µç®€æ´ã€æ²»æ„ˆä¸”å¯Œæœ‰å“²ç†çš„è§£è¯»ï¼Œå¹¶ç»™å‡ºä¸€ä¸ªæ˜ç¡®çš„è¡ŒåŠ¨å»ºè®®ã€‚
å­—æ•° 150 å­—å·¦å³ï¼Œè¯­æ°”æ¸©æŸ”ä¸”å……æ»¡æ™ºæ…§ã€‚`;

    try {
        if (!API_CONFIG.key || API_CONFIG.key.includes("ä½ çš„")) {
            throw new Error("è¯·åœ¨ä»£ç ç¬¬ 1165 è¡Œé…ç½®æ‚¨çš„å›½å†… API Key");
        }

        let result = "";
        if (API_CONFIG.isOpenAI) {
            // --- OpenAI å…¼å®¹æ ¼å¼ (é€‚ç”¨äº DeepSeek, é€šä¹‰åƒé—®, GPT ç­‰) ---
            const response = await fetch(API_CONFIG.endpoint, {
                method: 'POST',
                headers: { 
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${API_CONFIG.key}`
                },
                body: JSON.stringify({
                    model: API_CONFIG.modelName,
                    messages: [{ role: "user", content: prompt }]
                })
            });
            const data = await response.json();
            if (!response.ok) throw new Error(data.error?.message || `HTTP ${response.status}`);
            result = data.choices[0].message.content;
        } else {
            // --- Gemini æ ¼å¼ (é€‚ç”¨äºå›½å†…çš„ Gemini ä¸­è½¬åœ°å€) ---
            const response = await fetch(`${API_CONFIG.endpoint}?key=${API_CONFIG.key}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    contents: [{ parts: [{ text: prompt }] }]
                })
            });
            const data = await response.json();
            if (!response.ok) throw new Error(data.error?.message || `HTTP ${response.status}`);
            result = data.candidates[0].content.parts[0].text;
        }

        const contentEl = aiSection.querySelector('.ai-content');
        contentEl.style.opacity = "1";
        contentEl.style.fontStyle = "normal";
        contentEl.innerText = result;
        
        const dots = aiSection.querySelector('.loading-dots');
        if(dots) dots.remove();
        record.aiInterpretation = result;

    } catch (error) {
        console.error("AI Error:", error);
        aiSection.querySelector('.ai-content').innerHTML = `<span style="color: #ff4d4d;">ï¼ˆæ˜Ÿç•Œé€šè®¯å¤±è´¥ï¼š${error.message}ï¼‰</span>`;
        const dots = aiSection.querySelector('.loading-dots');
        if(dots) dots.remove();
    }
}

const READING_TEMPLATES = {
    openers: [
        "è¿™å¼ ç‰Œåƒæ˜¯åœ¨æé†’ä½ ï¼šåˆ«æ€¥ç€å®šä¹‰ç»“æœï¼Œå…ˆçœ‹æ¸…å½“ä¸‹çš„èƒ½é‡èµ°å‘ã€‚",
        "å®ƒæ›´åƒä¸€ç›ç¯ï¼Œç…§å‡ºä½ æ­£åœ¨ç»å†çš„ä¸»é¢˜ä¸éšå«çš„é€‰æ‹©ã€‚",
        "æŠŠå®ƒå½“ä½œä¸€æ¡è·¯æ ‡ï¼šæŒ‡å‘ä½ æ­¤åˆ»æœ€éœ€è¦é¢å¯¹çš„æ ¸å¿ƒé—®é¢˜ã€‚"
    ],
    advice: [
        "å…ˆæŠŠèƒ½æ§åˆ¶çš„éƒ¨åˆ†åšæ‰å®ï¼Œå‰©ä¸‹çš„äº¤ç»™æ—¶é—´å‘é…µã€‚",
        "æŠŠæ³¨æ„åŠ›ä»â€œåˆ«äººæ€ä¹ˆçœ‹â€æ”¶å›æ¥ï¼Œå›åˆ°ä½ çš„çœŸå®éœ€æ±‚ã€‚",
        "ç”¨æ›´å°çš„æ­¥éª¤æ¨è¿›ï¼šå…ˆå®Œæˆ 20%ï¼Œå†è¿­ä»£åˆ° 80%ã€‚"
    ],
    caution: [
        "é¿å…åœ¨æƒ…ç»ªé«˜ç‚¹/ä½è°·æ—¶åšä¸å¯é€†å†³å®šã€‚",
        "åˆ«æŠŠçŸ­æœŸæ³¢åŠ¨å½“æˆé•¿æœŸç»“è®ºã€‚",
        "è­¦æƒ•è¿‡åº¦æ‰¿è¯ºä¸æ‹–å»¶çš„ä¸¤ææ‘‡æ‘†ã€‚"
    ]
};

function pickOne(arr) {
    return arr[Math.floor(Math.random() * arr.length)];
}

function buildReading(record) {
    const { name, isReversed, meaning, ts } = record;
    const orientation = isReversed ? "é€†ä½" : "æ­£ä½";
    const opener = pickOne(READING_TEMPLATES.openers);
    const advice = pickOne(READING_TEMPLATES.advice);
    const caution = pickOne(READING_TEMPLATES.caution);

    const focus = isReversed
        ? "é€†ä½æ›´å¼ºè°ƒâ€œé˜»æ»/åå·®/å†…è€—â€ï¼Œå»ºè®®å…ˆå¤ç›˜åŸå› ï¼Œå†åšæ–¹å‘æ€§è°ƒæ•´ã€‚"
        : "æ­£ä½æ›´å¼ºè°ƒâ€œé¡ºåŠ¿/æ˜¾åŒ–/æ¨è¿›â€ï¼Œé€‚åˆæŠŠæœºä¼šè½åˆ°è¡ŒåŠ¨ä¸èŠ‚å¥ä¸Šã€‚";

    const timeStr = new Date(ts).toLocaleString();

    const chips = [
        `<span class="reading-chip">è§£è¯»æ—¶é—´ï¼š${timeStr}</span>`,
        `<span class="reading-chip">å–å‘ï¼š${orientation}</span>`
    ].join("");

    const html = `
        ${chips}
        <h4>æ€»ä½“</h4>
        <p>${opener}</p>
        <h4>ç‰Œæ„ï¼ˆ${orientation}ï¼‰</h4>
        <p>${meaning}</p>
        <h4>ä½ å¯ä»¥æ€ä¹ˆåš</h4>
        <p>${focus}</p>
        <p>${advice}</p>
        <h4>æé†’</h4>
        <p>${caution}</p>
    `;

    const plain = [
        `ã€${name}ï½œ${orientation}ã€‘`,
        `æ—¶é—´ï¼š${timeStr}`,
        "",
        "æ€»ä½“ï¼š",
        opener,
        "",
        `ç‰Œæ„ï¼ˆ${orientation}ï¼‰ï¼š`,
        meaning,
        "",
        "ä½ å¯ä»¥æ€ä¹ˆåšï¼š",
        focus,
        advice,
        "",
        "æé†’ï¼š",
        caution
    ].join("\n");

    return { html, plain, orientation };
}

function openReading(recordIndex) {
    const record = historyRecords[recordIndex];
    if (!record) return;

    const panel = document.getElementById('reading-panel');
    const nameEl = document.getElementById('reading-name');
    const orientEl = document.getElementById('reading-orientation');
    const bodyEl = document.getElementById('reading-body');

    const reading = buildReading(record);
    nameEl.textContent = record.name;
    orientEl.textContent = reading.orientation;
    bodyEl.innerHTML = reading.html;

    panel.classList.remove('hidden');
    panel.dataset.activeIndex = String(recordIndex);

    // Trigger AI interpretation if not already present
    if (!record.aiInterpretation) {
        fetchAIInterpretation(record);
    } else {
        // Show cached AI reading
        const aiSection = document.createElement('div');
        aiSection.innerHTML = `
            <div class="ai-header">âœ¨ AI ORACLE DECODING</div>
            <div class="ai-content">${record.aiInterpretation}</div>
        `;
        bodyEl.appendChild(aiSection);
    }
}

function closeReading() {
    const panel = document.getElementById('reading-panel');
    panel.classList.add('hidden');

    // If ash already finished, spawn next card after closing
    if (pendingNextCard && particles.length === 0 && !cardMesh) {
        pendingNextCard = false;
        setTimeout(() => spawnCard(), 350);
    }
}

async function copyReading() {
    const panel = document.getElementById('reading-panel');
    const idx = Number(panel.dataset.activeIndex);
    const record = historyRecords[idx];
    if (!record) return;
    const reading = buildReading(record);

    let textToCopy = reading.plain;
    if (record.aiInterpretation) {
        textToCopy += `\n\nAI æ·±åº¦è§£è¯»ï¼š\n${record.aiInterpretation}`;
    }

    try {
        await navigator.clipboard.writeText(textToCopy);
        document.getElementById('status-text').innerText = "å·²å¤åˆ¶è§£è¯»åˆ°å‰ªè´´æ¿";
    } catch (e) {
        window.prompt("å¤åˆ¶å¤±è´¥ï¼Œè¯·æ‰‹åŠ¨å¤åˆ¶ï¼š", textToCopy);
    }
}

function updateParticles() {
    for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.userData.life--;

        const positions = p.geometry.attributes.position.array;
        const velocities = p.geometry.attributes.velocity.array;
        
        for (let j = 0; j < positions.length / 3; j++) {
            // Update Pos
            positions[j * 3] += velocities[j * 3];     // x
            positions[j * 3 + 1] += velocities[j * 3 + 1]; // y
            positions[j * 3 + 2] += velocities[j * 3 + 2]; // z

            // Noise/Turbulence
            velocities[j * 3] += (Math.random() - 0.5) * 0.002;
            velocities[j * 3 + 2] += (Math.random() - 0.5) * 0.002;
        }

        p.geometry.attributes.position.needsUpdate = true;
        p.material.opacity = p.userData.life / 100;

        if (p.userData.life <= 0) {
            scene.remove(p);
            p.geometry.dispose();
            p.material.dispose();
            particles.splice(i, 1);
            // If ash finished and user already closed reading, spawn next
            if (particles.length === 0 && pendingNextCard) {
                const panel = document.getElementById('reading-panel');
                const isHidden = panel.classList.contains('hidden');
                if (isHidden && !cardMesh) {
                    pendingNextCard = false;
                    setTimeout(() => spawnCard(), 350);
                }
            }
        }
    }
}

// ================= ä¸»å¾ªç¯ä¸äº¤äº’é€»è¾‘ =================
function updateInteraction() {
    // Intro Deck Logic
    if (INTERACTION.state === 'INTRO') {
        updateIntroDeck();
        return;
    }

    if (!cardMesh || isProcessingEffect) return;

    INTERACTION.raycaster.setFromCamera(INTERACTION.pointer, camera);
    const intersects = INTERACTION.raycaster.intersectObject(cardMesh);
    const isHovered = intersects.length > 0;

    // State Machine
    const chargeBarContainer = document.getElementById('charge-bar-container');
    const chargeBar = document.getElementById('charge-bar');

    // Parallax Effect: Camera moves slightly opposite to pointer
    const parallaxX = INTERACTION.pointer.x * 0.5;
    const parallaxY = INTERACTION.pointer.y * 0.5;
    camera.position.x += (parallaxX - camera.position.x) * 0.05;
    camera.position.y += (parallaxY - camera.position.y) * 0.05;
    camera.lookAt(0, 0, 0);

    switch (INTERACTION.state) {
        case 'IDLE':
            chargeBarContainer.style.opacity = 0;
            // Float animation
            const time = Date.now() * 0.001;
            cardMesh.position.y = Math.sin(time) * 0.2;
            cardMesh.rotation.y = THREE.MathUtils.lerp(cardMesh.rotation.y, Math.PI, 0.1); 

            if (isHovered && INTERACTION.gesture === 'PINCH') {
                INTERACTION.state = 'GRABBED';
                document.getElementById('status-text').innerText = "é•¿æŒ‰æ¡æ‹³ / å³é”®è“„åŠ›ç¡®è®¤";
            } else if (isHovered) {
                cardMesh.scale.setScalar(1.05);
                document.body.style.cursor = 'pointer';
            } else {
                cardMesh.scale.setScalar(1.0);
                document.body.style.cursor = 'default';
            }
            break;

        case 'GRABBED':
            // Move card to pointer projection with smooth follow
            const targetZ = 2.0; 
            const vec = new THREE.Vector3(INTERACTION.pointer.x, INTERACTION.pointer.y, 0.5);
            vec.unproject(camera);
            const dir = vec.sub(camera.position).normalize();
            const distance = (targetZ - camera.position.z) / dir.z;
            const pos = camera.position.clone().add(dir.multiplyScalar(distance));
            
            // Add slight "weight" lag
            cardMesh.position.lerp(pos, 0.08);

            // Rotate to face front
            const targetRotZ = cardMesh.userData.isReversed ? Math.PI : 0;
            cardMesh.rotation.x = THREE.MathUtils.lerp(cardMesh.rotation.x, 0, 0.1);
            cardMesh.rotation.y = THREE.MathUtils.lerp(cardMesh.rotation.y, 0, 0.1);
            cardMesh.rotation.z = THREE.MathUtils.lerp(cardMesh.rotation.z, targetRotZ, 0.1);

            // Light up
            scene.userData.pointLight.intensity = 2;
            scene.userData.pointLight.position.copy(cardMesh.position);
            scene.userData.pointLight.position.z += 1;

            // Charge Logic (FIST)
            if (INTERACTION.gesture === 'FIST') {
                if (INTERACTION.fistStartTime === 0) INTERACTION.fistStartTime = Date.now();
                
                const duration = Date.now() - INTERACTION.fistStartTime;
                const progress = Math.min(duration / 1000, 1.0); // 1.0s to confirm
                
                // Visual feedback: Shake
                const shakeIntensity = 0.05 * progress;
                cardMesh.position.x += (Math.random() - 0.5) * shakeIntensity;
                cardMesh.position.y += (Math.random() - 0.5) * shakeIntensity;
                
                // UI feedback
                chargeBarContainer.style.opacity = 1;
                chargeBar.style.width = `${progress * 100}%`;
                
                if (progress >= 1.0) {
                    confirmSelection();
                    chargeBarContainer.style.opacity = 0;
                }
            } else {
                // Reset charge if released
                INTERACTION.fistStartTime = 0;
                chargeBarContainer.style.opacity = 0;
                chargeBar.style.width = '0%';
                
                if (INTERACTION.gesture === 'OPEN') {
                    INTERACTION.state = 'IDLE';
                    scene.userData.pointLight.intensity = 0;
                    document.getElementById('status-text').innerText = "å·²æ¾å¼€";
                }
            }
            break;
    }
}

function confirmSelection() {
    if (isProcessingEffect) return;
    isProcessingEffect = true;
    INTERACTION.state = 'LOCKED';

    const data = cardMesh.userData.data;
    const isRev = cardMesh.userData.isReversed;
    const meaning = isRev ? data.reversed : data.upright;
    const statusStr = isRev ? "(é€†ä½)" : "(æ­£ä½)";

    // Store history record
    const recordIndex = historyRecords.length;
    historyRecords.push({
        name: data.name,
        isReversed: isRev,
        meaning,
        ts: Date.now()
    });

    // Update UI History
    const historyPanel = document.getElementById('history-panel');
    const item = document.createElement('div');
    item.className = 'history-item';
    item.dataset.recordIndex = String(recordIndex);
    item.title = "ç‚¹å‡»æŸ¥çœ‹è§£è¯»";
    
    // Modern tag style
    const revTag = isRev ? `<span class="reversed-tag">R</span>` : '';
    
    item.innerHTML = `
        <div class="history-name">${data.name} ${revTag}</div>
        <div class="history-meaning">${meaning}</div>
    `;
    historyPanel.prepend(item);
    
    document.getElementById('status-text').innerText = `å·²è®°å½•ï¼š${data.name} ${statusStr}`;

    // Click to open reading
    item.addEventListener('click', () => openReading(recordIndex));

    // Auto open reading after confirm
    openReading(recordIndex);
    pendingNextCard = true;

    // Ash Effect
    createAshEffect(cardMesh.position);
    
    // Remove Card Mesh
    scene.remove(cardMesh);
    cardMesh.geometry.dispose();
    cardMesh.material.forEach(m => m.dispose());
    cardMesh = null;
    
    scene.userData.pointLight.intensity = 0;
}

function animate() {
    requestAnimationFrame(animate);

    const time = Date.now() * 0.001;
    
    // Update Shader Time
    if (cardMesh && cardMesh.userData.shaderMats) {
        cardMesh.userData.shaderMats.forEach(m => {
            if(m.uniforms) m.uniforms.time.value = time;
        });
    }
    // Also for spawnCard created mesh (which might not have shaderMats array structure yet, let's standarize)
    // Quick fix: check material[4]
    if (cardMesh && cardMesh.material && cardMesh.material[4] && cardMesh.material[4].uniforms) {
        cardMesh.material[4].uniforms.time.value = time;
    }

    updateInteraction();
    updateParticles();

    renderer.render(scene, camera);
}

// Start
window.onload = () => {
    inputManager.init();
    initScene();

    // Reading panel actions
    const btnClose = document.getElementById('btn-close-reading');
    const btnCopy = document.getElementById('btn-copy-reading');
    if (btnClose) btnClose.addEventListener('click', closeReading);
    if (btnCopy) btnCopy.addEventListener('click', copyReading);
};

// Resize handler
window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});

</script>
</body>
</html>

